%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Phaser Editor Documentation}
\date{Sep 12, 2017}
\release{1.4.2}
\author{Arian Fornaris}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{First Steps}
\label{\detokenize{first_steps:first-steps}}\label{\detokenize{first_steps::doc}}\label{\detokenize{first_steps:welcome-to-phaser-editor-s-documentation}}
This is a small guide you can follow to start writing your games and perform common tasks related to the editor’s features.


\section{Download and install}
\label{\detokenize{first_steps:download-and-install}}
\sphinxhref{http://phasereditor.boniatillo.com/blog/downloads}{Download the Phaser Editor ZIP file} of your OS (win64, linux64 or macosx) and uncompress it.


\subsection{Notes for Windows users}
\label{\detokenize{first_steps:notes-for-windows-users}}
To execute the editor just double click on the \sphinxcode{PhaserEditor.exe} file.


\subsection{Notes for MacOS users}
\label{\detokenize{first_steps:notes-for-macos-users}}
To execute the editor double click on the \sphinxcode{Phaser Editor} application. It is a simple \sphinxcode{.app} folder. By default the projects will be created in the \sphinxcode{\textasciitilde{}/Library/PhaserEditorProjects} folder.


\subsection{Notes for Linux users}
\label{\detokenize{first_steps:notes-for-linux-users}}
Before to run the editor you should set execution permission to some programs bundled in Phaser Editor. To do this, run the \sphinxcode{SetExecPermissions.sh} script:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} \PYG{l+s+s2}{\PYGZdq{}Phaser Editor\PYGZdq{}}
\PYGZdl{} chmod +x SetExecPermissions.sh
\PYGZdl{} ./SetExecPermissions.sh
\end{sphinxVerbatim}

Then run the editor as any other Linux program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./PhaserEditor
\end{sphinxVerbatim}

Phaser Editor was tested on Ubuntu 14.04 Gnome.

Some users are getting issues at the editor startup. Please \sphinxhref{https://github.com/boniatillo-com/PhaserEditor/issues/10}{check this issue to get a workaround}. Basically, the idea is to run the editor in this way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./PhaserEditor \PYGZhy{}persistState \PYG{n+nb}{false} \PYGZhy{}clearPersistedState
\end{sphinxVerbatim}


\section{The first run}
\label{\detokenize{first_steps:the-first-run}}
The first time you run Phaser Editor a Workspace Launcher dialog is open. In this dialog you have to set the path to the folder where you want to create the workspace.

A workspace is the container folder of your projects. All your projects will be created inside the workspace, but also, in the workspace are saved your preferences and UI state. This means, that if you start Phaser Editor and select a workspace, the editor will get the preferences saved there.

A project is a folder where you add the code of your game. So you can create many projects in the same workspace.

\noindent\sphinxincludegraphics{{WorkspaceLauncher}.png}


\section{Update}
\label{\detokenize{first_steps:update}}
By default when the editor opens it checks for available updates. We recommend you to install them, important bug fixes are provided this way.

\sphinxhref{update.html}{Learn more about the update process}


\section{Create a project}
\label{\detokenize{first_steps:create-a-project}}
In Phaser Editor there are two ways of creating a Phaser project: by using the \sphinxstylestrong{Phaser Project} wizard or the \sphinxstylestrong{Phaser Example Project} wizard.

Most users may use the \sphinxstylestrong{Phaser Project} wizard, it allows to set some parameters like the language (JavaScript/TypeScript), the layout (single/multiple state based game) and many others.

The \sphinxstylestrong{Phaser Example Project} wizard allows the user to create a project based on the official Phaser examples (and other examples, like the Phaser Editor demos). This way is great for users who start in Phaser and want to mess around with the examples.


\subsection{Phaser Project wizard}
\label{\detokenize{first_steps:phaser-project-wizard}}
To create the project go to \sphinxcode{File \textgreater{} New \textgreater{} Phaser Project}. It opens a dialog where, at the first page, asks for the name of the project:
\begin{quote}

\noindent\sphinxincludegraphics{{NewProject_SetName}.png}
\end{quote}

Write the name of your project and press the \sphinxstylestrong{Next} button if you want to change the project settings or press \sphinxstylestrong{Finish} to create the project with the default settings. We recommend you press \sphinxstylestrong{Next} and adjust some of the settings.

So, by pressing \sphinxstylestrong{Next} the wizard shows the settings page:

\noindent\sphinxincludegraphics{{NewProject_Settings}.png}

This page contains a group of parameters that affect different aspects of a project:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{Game Parameters}
&
Are the same parameters of the \sphinxcode{Phaser.Game} constructor.  Set these parameters to control how the game instance is created.
\\
\hline
\sphinxcode{Project Structure}
&
Contains a list of project layouts that you can select. You can select to create a project with a very simple structure or a complex, production ready structure. These layout are related with the number of Phaser states are going to be used in the game.
\\
\hline
\sphinxcode{Assets}
&
In this section you can set if you want to add some demo assets to the project. This could be good if you want to take a better idea of how a Phaser project is. In many of the layouts, when you select to add assets, some prefabs are created so it is a good way to know how prefabs work.
\\
\hline
\sphinxcode{Language}
&
To select the language of your project (JavaScript 5, JavaScript 6 or TypeScript). At the time there is not a built-in JavaScript 6/TypeScript editor inside Phaser Editor but we included this option because developers can use any other external editor like \sphinxhref{http://code.visualstudio.com}{VSCode}. There are some third-party plugins for Eclipse that support TypeScript, \sphinxhref{http://phasereditor.boniatillo.com/blog/2017/04/welcome-typescript-ide}{here we talk about one of them}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The current JavaScript editor does not support JavaScript 6, for that reason, if you select that language, a \sphinxhref{http://phasereditor.boniatillo.com/blog/2017/04/welcome-typescript-ide}{TypeScript IDE} project is created. We are going to include TypeScript IDE by default in the editor in the near future.

After setting the parameters, press the \sphinxstylestrong{Finish} button to create the project and files.

In dependence of your layout one file or other will be open to start editing the game. Usually what is opened is a visual scene file (canvas file) so you can start adding new objects to the game.

\sphinxhref{canvas.html}{Learn more about the scene editor}


\subsection{Phaser Example Project wizard}
\label{\detokenize{first_steps:phaser-example-project-wizard}}
In addition to the \sphinxstylestrong{Phaser Project} wizard there is the  \sphinxstylestrong{Phaser Example Project} wizard, that provide a list of templates based on Phaser examples.

\noindent\sphinxincludegraphics{{PhaserProject_Templates}.png}
\begin{itemize}
\item {} 
\sphinxstylestrong{Main Editor Demos}: provided by Phaser Editor. We recommend to start with them since it shows some the most important features in the editor, like the scene maker and the assets manager.

\item {} 
\sphinxstylestrong{Phaser Coding Tips}: contains the issues of the {[}official Phaser tutorials{]}{[}13{]}.

\item {} 
\sphinxstylestrong{Phaser Templates}: contains the templates listed in the Phaser github repo.

\item {} 
\sphinxstylestrong{Phaser Examples}: contains the official Phaser examples. These templates are a great resource to learn and test Phaser features, you can create a project, run it and modify it.

\end{itemize}

After you select the template you can press \sphinxstylestrong{Finish} to create a project with an auto-generated name, or click \sphinxstylestrong{Next} to change it.


\section{The Project Explorer}
\label{\detokenize{first_steps:the-project-explorer}}
The Project Explorer is a view with all the projects of the workspace. It is like a filesystem explorer, you can browse your projects and apply actions to the folders or files (open a file, create a folder, optimize the PNG of a folder, etc…).

A nice feature of Phaser Editor is the preview of the assets. In the Project Explorer you have two ways of preview the media files: hover the file with the mouse or select it and press \sphinxcode{CTRL+ALT+V}.

\noindent\sphinxincludegraphics{{ProjectExplorer}.png}

By default, Phaser Editor updates (refreshes) the Project Explorer if the workspace is changed by external programs (for example if you modify, delete or add a file in the OS explorer). However, you can refresh the Project Explorer manually if you select a resource (project, folder or file) and press \sphinxtitleref{F5} .


\section{Run the game}
\label{\detokenize{first_steps:run-the-game}}
To run your game there is a button in the main toolbar, it opens the default OS browser and start a built-in HTTP server to listen in a random free port. First you have to select, in the Project Explorer, the project you want to run, then press the Run Phaser Project button in the main toolbar (or press \sphinxcode{ALT+F5} ).

\noindent\sphinxincludegraphics{{RunProject}.png}

To run your game we said that you have to select the project of your game, but really you can select any file or folder of the project, or the file of the active editor can be used to know what project to run.

Phaser Editor has a built-in HTTP server to serve the static content of the projects. The first time you run a project, the server is started and serves all the static content of the workspace. So, in the browser is open an URL like: \sphinxcode{http://localhost:1982/YourGameName/WebContent/index.html}.


\section{Git}
\label{\detokenize{first_steps:git}}
Phaser Editor supports Git by default. You can learn how to version projects in the \sphinxhref{https://www.eclipse.org/egit/}{EGit page} .


\section{Learn Phaser}
\label{\detokenize{first_steps:learn-phaser}}
(This section is a promotion)

If you want to learn Phaser or go deeper in it, we recommend the following Zenva Academy courses:

\sphinxhref{https://academy.zenva.com/product/the-complete-mobile-game-development-course-platinum-edition/?a=42}{The Complete Mobile Game Development Course \textendash{} Platinum Edition}: Hands-on online course to learn iOS and Android Game Development from total scratch! Learn JavaScript, HTML5, Phaser and Cordova!

\noindent\sphinxincludegraphics{{zenva_course_1}.png}

\sphinxhref{https://academy.zenva.com/product/advanced-game-development-with-phaser/?a=42}{Advanced Game Development with Phaser}:  Become a Black Belt Phaser developer and create advanced games. Multiplayer included!

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{zenva_course_2}.jpeg}


\chapter{Assets Management}
\label{\detokenize{assets_manager:assets-management}}\label{\detokenize{assets_manager::doc}}
In Phaser Editor we encourage to use the \sphinxhref{http://www.html5gamedevs.com/topic/6807-new-phaser-asset-pack-feature-please-test}{Asset Pack JSON Format} to load the assets of your games, it allow a better organization and comprehension of the assets and we provide many features around this file, specially the scene maker.


\section{The asset pack}
\label{\detokenize{assets_manager:the-asset-pack}}
In the Phaser repository there is the file \sphinxcode{resources/Asset Pack JSON Format/assetPack.json}. It is an example of how the assets can be loaded via the asset pack. We reproduce here the Phaser’s authors explanation of that file:
\begin{quote}

An Asset Pack is a means to control the loading of assets into Phaser via a JSON file. Use \sphinxcode{Phaser.Loader.pack()} to load your data file.

The file is split into sections (…) Sections are a way for you to control the splitting-up of asset loading, so you don’t have to load everything at once.

The key you use for the sections is entirely up to you and is passed to the \sphinxcode{Phaser.Loader.pack} call.

Within each section is an Array of objects. Each object corresponds to a single file to be loaded. The “type” property controls the type of file. Note that lots of the file properties are optional. See the \sphinxcode{Phaser.Loader} API Documentation to find out which ones, as they match the API calls exactly.

Where a file type has a callback, such as “script”, the context in which the callback is run should be passed to the \sphinxcode{Phaser.Loader.pack} method. See the examples for further details.
\end{quote}


\section{Create the pack file}
\label{\detokenize{assets_manager:create-the-pack-file}}
If you create a project based on the built-in Phaser Editor templates then this file is created automatically. You can find it in the \sphinxcode{WebContent/assets/assets-pack.json} path.

To create the pack file manually, go to \sphinxcode{File \textgreater{} New \textgreater{} Asset Pack File}:

\noindent\sphinxincludegraphics{{NewAssetPackMenu}.png}

It opens the Asset Pack File wizard. In this wizard you should write the name of the file and select the folder where to create the pack. By default, it selects the \sphinxcode{assets} folder, but you can select any folder in any project. Press Finish to create the file and it opens in the Asset Pack editor.

\noindent\sphinxincludegraphics{{NewAssetPackSelectFolder}.png}


\section{The pack file editor}
\label{\detokenize{assets_manager:the-pack-file-editor}}
The Asset Pack file is a JSON file that you can edit manually, but in Phaser Editor this file can be modified using a dedicated editor with a graphical interface.

The editor has two panels: the assets tree and the asset details.

In the assets tree you add, remove and rename the sections and the entries. The asset details panel shows the properties of the object selected in the tree.

To modify an asset entry, you select it in the tree and change the values in the details panel.

The details panel also shows the JSDoc of the different parameters, it is the same doc of the parameters of the loader method.

For example, if you select an “image” object in the tree, the details panel shows the parameters of the \sphinxcode{Phaser.Loader.image()} method. You can modify the values of the parameters and you can see the documentation of it (hover the mouse in the parameter’s name).

\noindent\sphinxincludegraphics{{AssetPackEditor}.png}


\section{Load the assets from the pack file}
\label{\detokenize{assets_manager:load-the-assets-from-the-pack-file}}
In Phaser the asstes are loaded in the preload method of the game state. The code to load them looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{image}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}dino\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}path/to/dino.png\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{image}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}montain\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}path/to/montain.png\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{spritesheet}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}girl\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}path/to/mujer\PYGZhy{}trotando.png\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{audio}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}music\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}path/to/guajira.ogg\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{...}
\end{sphinxVerbatim}

For each asset to load you have to write a loader’s method call.

When you use an asset pack you only have to write a line to load a section from the asset pack:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{pack}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}level\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}path/to/assets\PYGZhy{}pack.json\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It automatically loads all the assets defined in the \sphinxcode{"level"} section of the pack \sphinxcode{assets-pack.json}.


\section{Assets explorer}
\label{\detokenize{assets_manager:assets-explorer}}
The Assets explorer is a key tool in Phaser Editor. It allows the user to navigate, preview, use and refactor the assets in a friendly way.


\subsection{Navigate the assets}
\label{\detokenize{assets_manager:navigate-the-assets}}
The Assets view show the hierarchy of the assets declared on the packs of the active project. The assets, as in the pack editor, are grouped in pack files and sections, but in addition you can get access to the frames of spritesheets or texture atlases. For example, a texture atlas is a node that you can expand to see all the sprites of the texture.

Since \sphinxcode{Phaser Editor v1.4}, the visual scenes and prefabs (Canvas files) are also available in the Assets view, in addition to the assets declared in the pack files.

\noindent\sphinxincludegraphics{{AssetsView}.png}

To open the Assets view type \sphinxcode{Ctrl+3} and write \sphinxcode{assets}. It shows you a list of elements related to the word \sphinxcode{assets}, just click the one that says \sphinxcode{Assets View}.


\subsection{Quick preview of the assets}
\label{\detokenize{assets_manager:quick-preview-of-the-assets}}
Many of the items in the Assets window can be quickly previewed: audio entries, videos, images, textures and Canvas (visual editor) files. Just hover the mouse on top of the element and a quick popup will show you the preview. Or drag the item and drop it in the \sphinxhref{./preview\_window.html}{Preview} window.

The icons and preview images of the assets are computed in a background process that is tiggered each time the assets change. Check the {\hyperref[\detokenize{assets_manager:troubleshooting}]{\sphinxcrossref{Troubleshooting}}} section below, there is explained how to fix some glitches related to assets.


\subsection{Add objects to a Canvas scene}
\label{\detokenize{assets_manager:add-objects-to-a-canvas-scene}}
In addition to the assets of the pack files, the Assets window show the visual scenes and prefabs (Canvas files). These files can be dragged from the Assets window and dropped into an open visual editor to create new objects.


\subsection{Assets references search}
\label{\detokenize{assets_manager:assets-references-search}}
To search all the references -in the whole project- of an asset could be a very desired feature in certain cases. In the Assets window you can rigth-click on an asset and select to search all the references.

\noindent\sphinxincludegraphics{{FindAssetsMenu}.png}

For now only Canvas scenes have references to the assets, so a search for references will show a list of objects in the scenes that are using the selected asset.

The result of  a search is shown in the Search window, and you can double click on any of the element to locate them in the visual scene editor.

\noindent\sphinxincludegraphics{{SearchAssetResults}.png}


\subsection{Assets refactoring}
\label{\detokenize{assets_manager:assets-refactoring}}
A nice new feature in Phaser Editor is the refactoring tools. These tools allow the user to change asset names, delete asset entries or replace asset textures by executing safe operations that can be undone.


\subsubsection{Delete an asset}
\label{\detokenize{assets_manager:delete-an-asset}}
To delete an asset entry right-click on it and select the \sphinxcode{Refactoring \textgreater{} Delete} option.  Please remember that an asset entry is just a definition, an entry, in the asset pack file. By deleting an asset entry you only are modifing the \sphinxcode{pack.json} file, the real file, like an image, is not touched.

\noindent\sphinxincludegraphics{{DeleteAssetMenu}.png}

\sphinxstyleemphasis{Note that some elements shown in the Assets view cannot be deleted. For example you cannot delete a frame of a texture atlas, you only can delete a complete texture atlas.}

After select the option to delete an asset, it opens a confirmation dialog with the option of preview the list of files that will be affected by the deletion.

\noindent\sphinxincludegraphics{{PreviewAffectedFiles}.png}


\subsubsection{Rename asset}
\label{\detokenize{assets_manager:rename-asset}}
The process of rename an asset is pretty similar to the process of delete it. A confirmation dialog is opened and the user can preview the affected files. The main difference is that if the user confirms the operation, then all the Canvas files will be updated to use the new name.


\subsubsection{Move asset}
\label{\detokenize{assets_manager:move-asset}}
Assets can be moved from one section to other. Just follow the same process of the rename, in the context menu select the \sphinxcode{Refactoring \textgreater{} Move} option. It shows a dialog to select the new section for the asset and the option to preview the affected files. This operation can be undone and updates all the affected files so it does not introduce errors.


\subsubsection{Global replace texture}
\label{\detokenize{assets_manager:global-replace-texture}}
This is a very useful operation and consists on replace certain texture (represented by an asset in the pack file) in all the objects of all the scenes of the project. These are the steps:
\begin{itemize}
\item {} 
Select the texture you want to replace. For example a demo texture that you want to replace for the final terxture.

\end{itemize}

\noindent\sphinxincludegraphics{{AssetReplaceMenu}.png}
\begin{itemize}
\item {} 
Select the texture replacement and confirm.

\end{itemize}

\noindent\sphinxincludegraphics{{SelectNewTextureReplacement}.png}

All the objects that used \sphinxcode{flor} as texture will be modified to use the texture \sphinxcode{zombi-head}.


\section{Troubleshooting}
\label{\detokenize{assets_manager:troubleshooting}}
If you find that your assets are in an invalid state or you see a strange behavior then to fix it you can try by cleaning the projects.

Internally Phaser Editor uses a memory model with all the assets and its properties. This memory model should be synchronized with the physical and real data, but it happens that sometime because external changes or maybe bugs, the memory model is not in synchronization with the physical one. In this case, the best is to force the editor to create the memory model from scratch.

To do this select in the main menu the option \sphinxcode{Project \textgreater{} Clean...}, it opens a dialog with the list of your projects. Select those you want to re-build and press the \sphinxstylestrong{OK} button. After this operation all the visual editors and views should be updated to show the new fresh/fixed data.

\noindent\sphinxincludegraphics{{CleanProjects}.png}

If the strange behavior continues please \sphinxhref{https://github.com/boniatillo-com/PhaserEditor/issues}{open an issue}.


\chapter{Canvas, The Scene Editor}
\label{\detokenize{canvas:canvas-the-scene-editor}}\label{\detokenize{canvas::doc}}
Canvas is a visual (WYSWYG) game level/object editor for Phaser. With this tool you can create a level or the prefabs (reusable objects) of the game, layout sprites and edit object properties like transformation, physics body and animation. The scenes are compiled to Phaser code, in JavaScript or TypeScript.
{}`
There are three type of Canvas files: states (compiled to a \sphinxcode{Phaser.State} code), sprite prefabs (compiled to \sphinxcode{Phaser.Sprite} code) and group prefabs (compiled to{}`Phaser.Group{}` code). These Phaser classes contain the code that create the objects of the game world. It is not like other tools like Tiled that uses a custom format to represent the objects layout and properties, else it compiles to a code that mimics what a developer can write with his “own hands”. This method has the advantage that the user can read and understand what is behind the scene and like in other tools provided in Phaser Editor, the developer can learn Phaser or reuse his current Phaser learnings.

When you create a scene (let’s say one named \sphinxcode{Level}) you get two files: \sphinxcode{Level.canvas} and \sphinxcode{Level.js}. The \sphinxcode{Level.canvas} file contains the objects of the scene and uses a custom Phaser Editor format. The \sphinxcode{Level.js} file is compiled from the \sphinxcode{Level.canvas} file and contains all the Phaser code that creates the real scene. Note that in a game distribution only the \sphinxcode{Level.js} file is needed, since \sphinxcode{Level.canvas} is only for design purpose.

Read in Zenva GameDev Academy \sphinxhref{https://gamedevacademy.org/make-a-mario-style-platformer-with-the-phaser-editor/}{Make a Mario-Style Platformer with the Phaser Editor}

\noindent\sphinxincludegraphics{{Canvas}.png}


\section{Play the demos}
\label{\detokenize{canvas:play-the-demos}}
To play around with a Canvas demo you can create a project with the \sphinxhref{first\_steps.html\#phaser-example-project-wizard}{Phaser Example Project wizard}. There you can select any of the templates under the \sphinxstylestrong{Phaser Editor Demos} category:

\noindent\sphinxincludegraphics{{PhaserProject_Templates}.png}


\section{States, sprites and groups}
\label{\detokenize{canvas:states-sprites-and-groups}}
In this section we are going to do a quick explanation of the difference and purpose of each type of Canvas: states, sprites and groups.


\subsection{The state scene}
\label{\detokenize{canvas:the-state-scene}}
A Phaser game is divided by states, for example the menu screen is coded in a state, a game level is coded in a state, the “game over” screen… What the user does is to write a special class that extends the \sphinxcode{Phaser.State} type, and implement some special methods where the creation and logic of the game is coded. These methods are the \sphinxcode{preload}, \sphinxcode{create}, \sphinxcode{update} and others.

This is an example of a state scene and the code compiled by Canvas:

A state with two coins…

\noindent\sphinxincludegraphics{{CanvasStateDemo}.png}

… is compiled into this code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} start generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}

\PYG{c+c1}{// Generated by Phaser Editor v1.4.0 (Phaser v2.6.2)}


\PYG{c+cm}{/**}
\PYG{c+cm}{ * DemoState.}
\PYG{c+cm}{ */}
\PYG{k+kd}{function} \PYG{n+nx}{DemoState}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{State}\PYG{p}{.}\PYG{n+nx}{call}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/** @type Phaser.State */}
\PYG{k+kd}{var} \PYG{n+nx}{DemoState\PYGZus{}proto} \PYG{o}{=} \PYG{n+nb}{Object}\PYG{p}{.}\PYG{n+nx}{create}\PYG{p}{(}\PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{State}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{DemoState}\PYG{p}{.}\PYG{n+nx}{prototype} \PYG{o}{=} \PYG{n+nx}{DemoState\PYGZus{}proto}\PYG{p}{;}
\PYG{n+nx}{DemoState}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{constructor} \PYG{o}{=} \PYG{n+nx}{DemoState}\PYG{p}{;}

\PYG{n+nx}{DemoState}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{init} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n+nx}{DemoState}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{preload} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{pack}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}level\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}assets/pack.json\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n+nx}{DemoState}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{create} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{119}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}coins\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{334}\PYG{p}{,} \PYG{l+m+mi}{129}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}coins\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} end generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}
\end{sphinxVerbatim}

To create a State scene click in the main menu the \sphinxcode{File \textgreater{} New \textgreater{} State File} option, it opens the State File wizard. The first page of that wizard asks for the parent folder and the name of the scene. Usually we create a \sphinxcode{WebContent/assets/canvas} folder where to place all the scenes and prefabs, but you are free to use any folder inside the \sphinxcode{WebContent} directory. In the next picture we use \sphinxcode{Level} as the name of the scene, that will create a \sphinxcode{Level.canvas} file. This is very important: the name of the file will be used to create the name of the state class.

\noindent\sphinxincludegraphics{{NewStateWizard_FilePage}.png}

If you press \sphinxstylestrong{Finish} the state file is created with the default parameters, but we recommend that you press the \sphinxstylestrong{Next} button, to do some customization of the scene:

\noindent\sphinxincludegraphics{{SceneWizard_Settings}.png}

Many of the parameters shown in that page come from the Phaser API, however there are other parameters like the \sphinxstylestrong{Base Class Name} or \sphinxstylestrong{Code Format} that are used by the scene-to-code compiler.

All these settings can be changed later in the configuration tab of the editor.

Sate scenes will be displayed in the \sphinxhref{assets\_manager.html\#assets-explorer}{Assets} window under the \sphinxstylestrong{State} section.


\subsection{The sprite scene (prefab)}
\label{\detokenize{canvas:the-sprite-scene-prefab}}
The sprite scene or sprite prefab is a Canvas file with a unique object that compiles to a \sphinxcode{Phaser.Sprite} sub-class. In the Phaser examples it is called as “custom sprite”, in other tutorials and examples about Phaser it is called also “prefab”. We like the word “prefab” since it is a concept used in other game visual tools, but the purpose is the same, to write resuable components that can be used in different parts of the game, without the need to duplicate code. For example you can create a \sphinxcode{Coin} prefab with the coin animations, so you can use that animated coin in any other scene.

This is an example of how an sprite canvas file is compiled into a custom \sphinxcode{Phaser.Sprite}:

The coin scene (with a \sphinxcode{rotate} animation)…

\noindent\sphinxincludegraphics{{CoinPrefab}.png}

… is compiled into a custom Sprite class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} start generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}

\PYG{c+c1}{// Generated by Phaser Editor v1.4.0 (Phaser v2.6.2)}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * Coin.}
\PYG{c+cm}{ * @param \PYGZob{}Phaser.Game\PYGZcb{} aGame A reference to the currently running game.}
\PYG{c+cm}{ * @param \PYGZob{}Number\PYGZcb{} aX The x coordinate (in world space) to position the Sprite at.}
\PYG{c+cm}{ * @param \PYGZob{}Number\PYGZcb{} aY The y coordinate (in world space) to position the Sprite at.}
\PYG{c+cm}{ * @param \PYGZob{}any\PYGZcb{} aKey This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.}
\PYG{c+cm}{ * @param \PYGZob{}any\PYGZcb{} aFrame If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.}
\PYG{c+cm}{ */}
\PYG{k+kd}{function} \PYG{n+nx}{Coin}\PYG{p}{(}\PYG{n+nx}{aGame}\PYG{p}{,} \PYG{n+nx}{aX}\PYG{p}{,} \PYG{n+nx}{aY}\PYG{p}{,} \PYG{n+nx}{aKey}\PYG{p}{,} \PYG{n+nx}{aFrame}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k+kd}{var} \PYG{n+nx}{pKey} \PYG{o}{=} \PYG{n+nx}{aKey} \PYG{o}{===} \PYG{k+kc}{undefined}\PYG{o}{?} \PYG{l+s+s1}{\PYGZsq{}coins\PYGZsq{}} \PYG{o}{:} \PYG{n+nx}{aKey}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{pFrame} \PYG{o}{=} \PYG{n+nx}{aFrame} \PYG{o}{===} \PYG{k+kc}{undefined}\PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{n+nx}{aFrame}\PYG{p}{;}

        \PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Sprite}\PYG{p}{.}\PYG{n+nx}{call}\PYG{p}{(}\PYG{k}{this}\PYG{p}{,} \PYG{n+nx}{aGame}\PYG{p}{,} \PYG{n+nx}{aX}\PYG{p}{,} \PYG{n+nx}{aY}\PYG{p}{,} \PYG{n+nx}{pKey}\PYG{p}{,} \PYG{n+nx}{pFrame}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{scale}\PYG{p}{.}\PYG{n+nx}{setTo}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}anim\PYGZus{}rotate} \PYG{o}{=} \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{animations}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}rotate\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// public fields}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{fCoins} \PYG{o}{=} \PYG{k}{this}\PYG{p}{;}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{fAnim\PYGZus{}rotate} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}anim\PYGZus{}rotate}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/** @type Phaser.Sprite */}
\PYG{k+kd}{var} \PYG{n+nx}{Coin\PYGZus{}proto} \PYG{o}{=} \PYG{n+nb}{Object}\PYG{p}{.}\PYG{n+nx}{create}\PYG{p}{(}\PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Sprite}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{Coin}\PYG{p}{.}\PYG{n+nx}{prototype} \PYG{o}{=} \PYG{n+nx}{Coin\PYGZus{}proto}\PYG{p}{;}
\PYG{n+nx}{Coin}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{constructor} \PYG{o}{=} \PYG{n+nx}{Coin}\PYG{p}{;}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} end generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}
\end{sphinxVerbatim}

To create a sprite prefab in the main menu select the \sphinxcode{File \textgreater{} New \textgreater{} Sprite Prefab File} option. It opens a wizard that in its first page ask for the container folder and the name of the file.

Press the \sphinxstylestrong{Next} button to set some needed parameters, the most important is the texture of the sprite:

\noindent\sphinxincludegraphics{{CreateSpritePrefab}.png}

In the current version of Canvas the sprites cannot have children, so a sprite prefab cannot have children neither, it is a file with single object.


\subsection{The group scene (prefab)}
\label{\detokenize{canvas:the-group-scene-prefab}}
In Phaser a group is an object with different purpose. It can be used as a pool of objects or like a transformation list of objects. As well as the sprites, you can create “custom groups”, or what we name group prefabs. These group prefabs can be added to other scenes so they are a way to write reusable components. For example you can create a tree with fruits and use it in different levels.

This group prefab…

\noindent\sphinxincludegraphics{{GroupPrefab}.png}

… is compiled into this code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} start generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}

\PYG{c+c1}{// Generated by Phaser Editor v1.4.0 (Phaser v2.6.2)}


\PYG{c+cm}{/**}
\PYG{c+cm}{ * Tree.}
\PYG{c+cm}{ * @param \PYGZob{}Phaser.Game\PYGZcb{} aGame A reference to the currently running game.}
\PYG{c+cm}{ * @param \PYGZob{}Phaser.Group\PYGZcb{} aParent The parent Group (or other \PYGZob{}@link DisplayObject\PYGZcb{}) that this group will be added to.}
\PYG{c+cm}{    If undefined/unspecified the Group will be added to the \PYGZob{}@link Phaser.Game\PYGZsh{}world Game World\PYGZcb{}; if null the Group will not be added to any parent.}
\PYG{c+cm}{ * @param \PYGZob{}string\PYGZcb{} aName A name for this group. Not used internally but useful for debugging.}
\PYG{c+cm}{ * @param \PYGZob{}boolean\PYGZcb{} aAddToStage If true this group will be added directly to the Game.Stage instead of Game.World.}
\PYG{c+cm}{ * @param \PYGZob{}boolean\PYGZcb{} aEnableBody If true all Sprites created with \PYGZob{}@link \PYGZsh{}create\PYGZcb{} or \PYGZob{}@link \PYGZsh{}createMulitple\PYGZcb{} will have a physics body created on them. Change the body type with \PYGZob{}@link \PYGZsh{}physicsBodyType\PYGZcb{}.}
\PYG{c+cm}{ * @param \PYGZob{}number\PYGZcb{} aPhysicsBodyType The physics body type to use when physics bodies are automatically added. See \PYGZob{}@link \PYGZsh{}physicsBodyType\PYGZcb{} for values.}
\PYG{c+cm}{ */}
\PYG{k+kd}{function} \PYG{n+nx}{Tree}\PYG{p}{(}\PYG{n+nx}{aGame}\PYG{p}{,} \PYG{n+nx}{aParent}\PYG{p}{,} \PYG{n+nx}{aName}\PYG{p}{,} \PYG{n+nx}{aAddToStage}\PYG{p}{,} \PYG{n+nx}{aEnableBody}\PYG{p}{,} \PYG{n+nx}{aPhysicsBodyType}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Group}\PYG{p}{.}\PYG{n+nx}{call}\PYG{p}{(}\PYG{k}{this}\PYG{p}{,} \PYG{n+nx}{aGame}\PYG{p}{,} \PYG{n+nx}{aParent}\PYG{p}{,} \PYG{n+nx}{aName}\PYG{p}{,} \PYG{n+nx}{aAddToStage}\PYG{p}{,} \PYG{n+nx}{aEnableBody}\PYG{p}{,} \PYG{n+nx}{aPhysicsBodyType}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{41}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}objects\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Tree\PYGZus{}3\PYGZsq{}}\PYG{p}{,} \PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{103}\PYG{p}{,} \PYG{l+m+mi}{87}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}objects\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}fruit\PYGZsq{}}\PYG{p}{,} \PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{147}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}objects\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}fruit\PYGZsq{}}\PYG{p}{,} \PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{190}\PYG{p}{,} \PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}objects\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}fruit\PYGZsq{}}\PYG{p}{,} \PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{243}\PYG{p}{,} \PYG{l+m+mi}{47}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}objects\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}fruit\PYGZsq{}}\PYG{p}{,} \PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{95}\PYG{p}{,} \PYG{l+m+mi}{221}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}objects\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}Bush (1)\PYGZsq{}}\PYG{p}{,} \PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/** @type Phaser.Group */}
\PYG{k+kd}{var} \PYG{n+nx}{Tree\PYGZus{}proto} \PYG{o}{=} \PYG{n+nb}{Object}\PYG{p}{.}\PYG{n+nx}{create}\PYG{p}{(}\PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Group}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{Tree}\PYG{p}{.}\PYG{n+nx}{prototype} \PYG{o}{=} \PYG{n+nx}{Tree\PYGZus{}proto}\PYG{p}{;}
\PYG{n+nx}{Tree}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{constructor} \PYG{o}{=} \PYG{n+nx}{Tree}\PYG{p}{;}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} end generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}
\end{sphinxVerbatim}

To create a group prefab select in the main menu the \sphinxcode{File \textgreater{} New \textgreater{} Group Prefab File} option. It opens a wizard that ask in the first page for the name of the file. You can press the \sphinxstylestrong{Finish} button to create the file or press \sphinxstylestrong{Next} to customize some options, like the base class name (other than \sphinxcode{Phaser.Group}) or the code format (JavaScript 5, JavaScript 6 or TypeScript).


\section{Objects creation}
\label{\detokenize{canvas:objects-creation}}
In general, a Canvas scene is formed by a tree of objects (sprites) and a couple of configuration parameters. In this section we are going to explain how to add the objects.


\subsection{Related Phaser concepts}
\label{\detokenize{canvas:related-phaser-concepts}}
In Phaser the common syntax to create the sprites is like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}enemy\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{game} var is a reference to the global game instance, the first two arguments are the position of the sprite (\sphinxcode{10, 10}) and the last argument is the asset key of a texture. The assets of the game are stored in a cache and identified by a key that is declared in the \sphinxcode{preload} method, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{preload}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{image}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}enemy\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}assets/monster.png\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

For the scenes Phaser Editor uses an \sphinxhref{assets\_manager.html}{Asset manifest file (pack)} that contains the declaretion of the assets and the keys. Instead of write the code to load each asset, you only need to load the asset pack file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{pack}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}level\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}assets/pack.json\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

That loading code is written in the \sphinxcode{preload} method of the states, so if the state was compiled from a Canvas file then it is generated automatically.


\subsection{By dropping a texture asset}
\label{\detokenize{canvas:by-dropping-a-texture-asset}}
The common way to create an object is by getting a texture from somewhere and droping it into the scene. In the next sections we explain the different sources of the textures.


\subsubsection{From the Assets window}
\label{\detokenize{canvas:from-the-assets-window}}
In the \sphinxhref{assets\_manager.html\#assets-explorer}{Assets} explorer you will find all the assets declared in the pack files. To create a common sprite you can drag a texture from that window and drop it into the scene:

\noindent\sphinxincludegraphics{{AddObjectFromAssets}.png}

Note a texture could be represented by an image key, a sprite-sheet frame key or a texture atlas frame key.

The objects created by dropping an asset in the scene are simple sprites, direct instances of \sphinxcode{Phaser.Sprite}. In the next sections we explain how to create specialized sprites like buttons and tiles.

From the Assets view you can add prefabs too. Look for the \sphinxstylestrong{Sprites} and \sphinxstylestrong{Group} sections of that window. When the prefab is dropped into the scene then a prefab instance is created. This is how looks a code compiled from a Sate scene that contains prefab instances. Note the difference between to add a sprite from a texture (\sphinxcode{bg}) and a sprite from a prefab (\sphinxcode{Tree}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{Level}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{create} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}bg\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}tree} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Tree}\PYG{p}{(}\PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{game}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}tree}\PYG{p}{.}\PYG{n+nx}{position}\PYG{p}{.}\PYG{n+nx}{setTo}\PYG{p}{(}\PYG{l+m+mi}{39}\PYG{p}{,} \PYG{l+m+mi}{130}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{From the Preview window}
\label{\detokenize{canvas:from-the-preview-window}}
The \sphinxhref{preview\_window.html}{Preview window} allow you you to get a closer look to the assets. Like in the Assets window, you can drag an asset key from the Preview and drop it to the scene. For example, you can drop “cells” from a sprite-sheet of a retro game into the scene. This method could be easier than getting it from the Assets tree:

\noindent\sphinxincludegraphics{{AddObjectFromPreview}.png}

You can drag the objects from an image, a texture atlas or a sprite-sheet.


\subsubsection{From the Palette}
\label{\detokenize{canvas:from-the-palette}}
The Palette is a docked window at the right of the scene and is used to keep at hand a selection of assets that you use often. You can add assets to the palette in the same way you add them to the scene. One time the assets are in the palette you can drag them from there and drop them into the scene. To show the palette you can click on the palette icon.

\noindent\sphinxincludegraphics{{AddAssetFromPalette}.png}


\subsubsection{From the context menu}
\label{\detokenize{canvas:from-the-context-menu}}
If you like to work without distracting windows around you can maximize the scene editor (\sphinxcode{Ctrl+M}) so it gets all the application space. In this mode you have the option to add the objects by using the Add Sprite dialog, just right-click on the scene and select \sphinxcode{Sprite \textgreater{} Add... \textgreater{} Sprite}:

\noindent\sphinxincludegraphics{{AddSpriteMenu}.png}

It shows a dialog with all the assets that can be used to create the sprite:

\noindent\sphinxincludegraphics{{AddSpriteDialog}.png}

As you can see in the previous menu, you can add other type of objects like buttons (\sphinxcode{Phaser.Button}), tiles (\sphinxcode{Phaser.TileSprite}) and prefabs. It does the same, to open a dialog with the asstes or prefabs to be added but it creates an object of different type.


\subsubsection{Selecting the container}
\label{\detokenize{canvas:selecting-the-container}}
It is a very common case when you want to add the new object to a specific group. To do this just select the group and then add the object to the scene. For example if you want to add more blocks to the \sphinxcode{ground} group, then select \sphinxcode{ground} and then add the objects to the scene. If instead of a group you select a sprite and add a new object, this object will be added to the parent of the selected sprite. For example, if you select a \sphinxcode{block} sprite and add a new object then it will be inserted into the block’s parent group, in this case the \sphinxcode{ground} group.


\subsection{Group creation}
\label{\detokenize{canvas:group-creation}}
You can create an empty group or a group with the selected objects as children:

\noindent\sphinxincludegraphics{{AddGroupMenu}.png}

Note to create a group with the selection objects you can press the \sphinxcode{G} key.

Other group operations are:
\begin{itemize}
\item {} 
Break group (\sphinxcode{Shift+G}): it reparent the children and destroy the group.

\item {} 
Trim group (\sphinxcode{T}): it remove the blank spaces around the children.

\end{itemize}


\subsection{Object morphing}
\label{\detokenize{canvas:object-morphing}}
The common way to create an object is by adding an asset into the scene and it create a regular sprite (\sphinxcode{Phaser.Sprite}). If you want to create a different type of object (like a button or a tile) you have two options: the \sphinxtitleref{From the context menu} option or the morphing option.

To morphing an object mean to convert an object from one type to other type, for example, to morph a sprite into a button or into a tile sprite. When you morph an object into other type it keeps the same proprties, like transformation, texture, body.

To morph an object right click on it and select one of the options displayed in the \sphinxcode{Sprite \textgreater{} Morph To...} menu:

\noindent\sphinxincludegraphics{{MorphObjectTo}.png}

In addition you can press the \sphinxcode{L} key to morph the selected sprite to a tile sprite, and resize it. It is a handy shortcut for games based on fixed-size art. If the sprite is already a tile sprite it just show the handlers to resize it.


\subsection{Dynamic object creation}
\label{\detokenize{canvas:dynamic-object-creation}}
Many genres of games create the levels dynamically, or part of the levels. With Canvas you can design the sprite and group prefabs and then create instances of them dinamically.


\subsubsection{Dynamic creation of sprite prefab objects}
\label{\detokenize{canvas:dynamic-creation-of-sprite-prefab-objects}}
To create a sprite prefab dynamically follow this syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{coin} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Coin}\PYG{p}{(}\PYG{n+nx}{game}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{existing}\PYG{p}{(}\PYG{n+nx}{coin}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Where \sphinxcode{game} is a reference to the \sphinxcode{Phaser.Game} instance and \sphinxcode{10, 10} is the location of the object, and \sphinxcode{Coin} is the name of a sprite prefab.

If you want to add the sprite to a group, then the syntax is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{coin} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Coin}\PYG{p}{(}\PYG{n+nx}{game}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{parentGroup}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{n+nx}{coin}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can also create the sprite with a different texture:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{coin} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{Coin}\PYG{p}{(}\PYG{n+nx}{game}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}atlas\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}blue\PYGZhy{}coin\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Where \sphinxcode{'atlas'} is the name of a texture loaded with the \sphinxcode{atlas} key, and \sphinxcode{'blue-coin'} is the name of a frame of the texture.


\subsubsection{Dynamic creation of group prefab objects}
\label{\detokenize{canvas:dynamic-creation-of-group-prefab-objects}}
Just like sprite prefabs you can create group prefabs like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{group} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{SkyBackground}\PYG{p}{(}\PYG{n+nx}{game}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Where \sphinxcode{game} is an instance of the Phaser game and \sphinxcode{SkyBackground} is a group prefab.

If you want to add the new group to a parent group then this is the syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{group} \PYG{o}{=} \PYG{k}{new} \PYG{n+nx}{SkyBackground}\PYG{p}{(}\PYG{n+nx}{game}\PYG{p}{,} \PYG{n+nx}{parentGroup}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Scene navigation}
\label{\detokenize{canvas:scene-navigation}}
For large scenes it is very important to navigate the tree of objects and quickly find specific objects. In the next section we show the tools provided by Phaser Editor for this purpose.


\subsection{The Outline window}
\label{\detokenize{canvas:the-outline-window}}
In the top/left corner of the editor there is the Outline window. It shows the hierarchy of the scene objects. There you can filter, select, delete, group and move the objects of the scene:

\noindent\sphinxincludegraphics{{CanvasOutline}.png}


\subsection{The Quick Outline window}
\label{\detokenize{canvas:the-quick-outline-window}}
In addition there is the Quick Outline window. It is opened by the user with the key sequence \sphinxcode{Ctrl+O}. The object selected by the user is focused in the scene, so it can be used as a search tool too.

This quick window is very useful when the scene left panel is hidden to gain on space.

\noindent\sphinxincludegraphics{{CanvasQuickOutline}.png}


\section{Object properties}
\label{\detokenize{canvas:object-properties}}
To edit the scene object properties there is the Properties Grid window. The Phaser objects contain a lot of properties, but in Canvas we just support a subset of them, specially those that have an impact on the visuality of the objects.

To edit the properties of an object follow these steps:
\begin{itemize}
\item {} 
Select the object -you cannot edit many objects at the same time- in the scene or in the Outline window.

\item {} 
The object’s properties are shown in the Property Grid.

\item {} 
Click on the value of a property and change it. Then press ENTER to apply that change. In case of numeric properties, you can write a math expression like \sphinxcode{15*30}, then it is evaluated and the result is set as value.

\item {} 
Some properties have special editors that open in a separated window.

\item {} 
You always can undo the change by pressing \sphinxcode{Ctrl+Z}.

\end{itemize}

\noindent\sphinxincludegraphics{{PropertyGrid}.png}

As you can note, in the top of the grid there is a text field with a “type filter text” message, it helps to filter the list of properties and find the one of your interest.

As alternative to the Property Grid, you can open the Quick Edit dialog (by pressing \sphinxtitleref{Q} or clicking in the button of the toolbar). It is actually the same thing of the Property Grid but it is shown in a popup dialog.

A nice feature is that you can hover the mouse over a property and it displays the help of it. This help is the same of the Phaser API, actually, that help is taken from the Phaser metadata generated by Phaser Editor, by parsing the Phaser sources.

\noindent\sphinxincludegraphics{{PropertyGridHelp}.png}

When you change a property it is highlighted with a bold font, and generated in the code in this way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{sprite} \PYG{o}{=} \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}wall\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{sprite}\PYG{p}{.}\PYG{n+nx}{tint} \PYG{o}{=} \PYG{l+m+mh}{0xfcfcfc}\PYG{p}{;} \PYG{c+c1}{// modified property}
\end{sphinxVerbatim}


\subsection{Common object properties}
\label{\detokenize{canvas:common-object-properties}}
All the objects in the scene share a common set of properties:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Property
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{name}
&
A user defined name. This value isn’t ever used internally by Phaser or Phaser Editor.
\\
\hline
\sphinxcode{x/y}
&
The position of the Game Object on the x axis relative to the local coordinates of the parent.
\\
\hline
\sphinxcode{angle}
&
The angle property is the rotation of the object in \sphinxstyleemphasis{degrees}.
\\
\hline
\sphinxcode{scale.x/y}
&
The scale of the object.
\\
\hline
\sphinxcode{pivot.x/y}
&
The pivot point of this object that it rotates around.
\\
\hline
\sphinxcode{alpha}
&
The alpha value of the object. 0 is transparent, 1 is fully opaque.
\\
\hline
\sphinxcode{fixedToCamera}
&
If true the Game Object will appear to be ‘fixed’ to the camera, regardless of where in the game world the camera is viewing. Useful for backgrounds or UI elements in scrolling games.
\\
\hline
\sphinxcode{renderable}
&
Whether this object is renderable or not. Often used in Phaser Editor to create hidden layers with physics bodies.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Transformation tools}
\label{\detokenize{canvas:transformation-tools}}
In addition to set the values directly in the property grid you can change the transformation of an object by selecting it and executing one of the transformation commands. It shows little handlers that you can drag to transform the object. The commands can be executed from the context menu under the \sphinxcode{Object \textgreater{} Transform} menu, or by pressing the key shortcuts: scale (\sphinxcode{S}), rotate (\sphinxcode{N}).

\noindent\sphinxincludegraphics{{TransformObject}.png}

\noindent\sphinxincludegraphics{{TransformObjectTool}.png}


\subsection{Prefab instance properties}
\label{\detokenize{canvas:prefab-instance-properties}}
By default the properties of a prefab instance cannot be changed, the \sphinxcode{position} and \sphinxcode{override} properties are the exception. The \sphinxcode{override} property contains the list of properties that can be changed in that prefab instance. It means, that if you want to change the scale of a prefab instance then first step is to “open” the scale property by checking it on the \sphinxcode{override} list. Note that when a property is not checked in the \sphinxcode{override} list it is shown as disabled in the Property Grid and cannot be edited.

To reset the value of a property to the initial value in the prefab just deselect the property in the \sphinxcode{override} list.

\noindent\sphinxincludegraphics{{OverridePrefabProperty}.png}


\subsection{Sprite properties}
\label{\detokenize{canvas:sprite-properties}}
The \sphinxcode{Phaser.Sprite} is the common class for all the game objects based on textures. In this section we show the properties supported by Phaser Editor and the some dedicated property editors.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Property
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{anchor.x/y}
&
The anchor sets the origin point of the texture. The default is 0,0 this means the texture’s origin is the top left Setting than anchor to 0.5,0.5 means the textures origin is centered Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner.
\\
\hline
\sphinxcode{tint}
&
The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF (white) will remove any tint effect. To edit this value the editor shows the native color dialog.
\\
\hline
\sphinxcode{animations}
&
A list of animations. This property is explained in the {\hyperref[\detokenize{canvas:animations}]{\sphinxcrossref{Animations}}} section.
\\
\hline
\sphinxcode{data}
&
An empty object where the user can add custom properties. See the {\hyperref[\detokenize{canvas:user-data}]{\sphinxcrossref{User data}}} section.
\\
\hline
\sphinxcode{frameName}
&
This property is shown only for sprites with a texture based on a texture atlas frame. When the user edits this property it shows a dialog with all the frames of the atlas. Read more in the {\hyperref[\detokenize{canvas:texture}]{\sphinxcrossref{Texture}}} section.
\\
\hline
\sphinxcode{frame}
&
This property is shown only for sprites with a texture based on a sprite-sheet frame index. When the user edits this property it shows a dialog with all the frames of the sprite-sheet. Read more in the {\hyperref[\detokenize{canvas:texture}]{\sphinxcrossref{Texture}}} section.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Arcade Physics}
\label{\detokenize{canvas:arcade-physics}}
For now the scene editor only supports Arcade physics. It does not mean that you cannot add other type of physics to your game, else that you should setup the other physics bodies by hand, without any special tool.

To enable Arcade physics on a sprite you have two options:
\begin{itemize}
\item {} 
Set \sphinxcode{true} the \sphinxcode{physicsGroup} property of the parent group of the sprite. Physics bodies are automatically enabled in objects added to a physics group.

\item {} 
Select the object and open the context menu, in the \sphinxcode{Sprite \textgreater{} Arcade} menu there are two commands: \sphinxcode{Set Arcade Body - Rectangular} and \sphinxcode{Set Arcade Body - Circular}, both commands enable a physics body (rectangular or circular) in the selected object.

\end{itemize}

\noindent\sphinxincludegraphics{{SpriteArcadeMenu}.png}

When you add a body to a sprite, a new section \sphinxcode{Arcade} is added to the Property Grid. This section contains many properties related to the Arcade physics body of the sprite and can be edited. In addition you can visually edit the size and offset of the body, just right click on the sprite and select \sphinxcode{Sprite \textgreater{} Arcade \textgreater{} Edit Body} or press the \sphinxcode{B} key.

\noindent\sphinxincludegraphics{{EditArcadeBody}.png}


\subsubsection{Animations}
\label{\detokenize{canvas:animations}}
The \sphinxcode{animations} property is reference to the \sphinxcode{Phaser.AnimationManager} of the sprite. This manager contains a list of sprite animations and provide methods to manipulate the animations like \sphinxcode{add}, \sphinxcode{play}, \sphinxcode{stop} and others.

When the user click to edit the \sphinxcode{animations} of a sprite it opens a dialog with the list of the animations together with an area to preview them:

\noindent\sphinxincludegraphics{{AnimationsDialog}.png}

As you can see in the dialog you can add/remove animation, add/remove frames to an animation sequence, edit each animation properties and play an animation. The animations properties you can edit are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Property
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{Frame Rate}
&
The animation speed in frames per second.
\\
\hline
\sphinxcode{Loop}
&
To repeat the animation.
\\
\hline
\sphinxcode{Kill On Complete}
&
If checked the animation will be played once and then destroyed.
\\
\hline
\sphinxcode{Auto Play}
&
If checked the animation will be played just after it is created. Only one animation can be auto-played.
\\
\hline
\sphinxcode{Public}
&
If checked a field will be generated to reference this animation. Useful if you want to publish animations of prefabs.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The animations are compiled into code in this way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}dino} \PYG{o}{=} \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}dino\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}dino\PYGZus{}walk} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}dino}\PYG{p}{.}\PYG{n+nx}{animations}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}walk\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{\PYGZus{}dino\PYGZus{}walk}\PYG{p}{.}\PYG{n+nx}{play}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// the \PYGZdq{}walk\PYGZdq{} animation was set to Auto Play}
\PYG{n+nx}{\PYGZus{}dino}\PYG{p}{.}\PYG{n+nx}{animations}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}jump\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kc}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{\PYGZus{}dino}\PYG{p}{.}\PYG{n+nx}{animations}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}stay\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kc}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If the animation \sphinxcode{jump} was set to Public then a field \sphinxcode{fDino\_jump} will be generated:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}dino\PYGZus{}jump} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}dino}\PYG{p}{.}\PYG{n+nx}{animations}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}jump\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kc}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{\PYGZus{}dino}\PYG{p}{.}\PYG{n+nx}{animations}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}stay\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kc}{false}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// public fields}

\PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{fDino\PYGZus{}jump} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}dino\PYGZus{}jump}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{User data}
\label{\detokenize{canvas:user-data}}
The \sphinxcode{data} property of the sprites is a reference to an empty object where the user can put any attribute. Often this data is used top create small variations between the sprites without the need to create new sprite types (or prefabs). In Phaser Editor you can set the JSON value of that property. When the user click it to edit it opens a dialog with a text editor where you can write the JSON values:

\noindent\sphinxincludegraphics{{DataDialog}.png}

For example, if you have some enemies in a level that walk from one side to other, you can set in the \sphinxcode{data} property the \sphinxcode{velocity} and the \sphinxcode{left} and \sphinxcode{right} borders of the enemy walk. Each enemy will get a different movement range. In the \sphinxcode{update} method of the level you can read that information for each enemy and update its position.


\subsubsection{Texture}
\label{\detokenize{canvas:texture}}
Canvas support three different type of textures: image, sprite-sheet frame and atlas frame. If the sprite is based on atlas or sprite-sheet, the user can change the frame by editing the \sphinxcode{frameName} or \sphinxcode{frame} property. In addition there is a \sphinxcode{Change Texture} command that allow the user to replace the texture for any other texture type. This command is available in the context menu \sphinxcode{Sprite \textgreater{} Change Sprite Texture} or can be executed by pressing \sphinxcode{Ctrl+T}. It opens a dialog with all the textures declared in the asset pack. This command allow to select more than one sprite so you can change the texture of all of them.

\noindent\sphinxincludegraphics{{ChangeTextureDialog}.png}

Another nice command is \sphinxcode{Sprite \textgreater{} Select All Sprites With Same Texture}, it selects all the sprites in the same scene with the same texture of the selection. It helps to replace demo textures by final textures.

In addition Phaser Editor provides texture refactorings, it is a process that allow to change the texture of all the sprites of all the scenes. You can read more about it the \sphinxhref{assets\_manager.html\#global-replace-texture}{Global replace texture} section.


\subsection{Button properties}
\label{\detokenize{canvas:button-properties}}
The button object (\sphinxcode{Phaser.Button}) inherites all the properties from the sprite and adds the following:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Property
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{callback}
&
The function to call when the button is pressed.
\\
\hline
\sphinxcode{callbackContext}
&
The context which the callback will be called (\sphinxcode{this} by default).
\\
\hline
\sphinxcode{overFrame}
&
The \sphinxcode{frame}/\sphinxcode{frameName} when the button is in the Over state.
\\
\hline
\sphinxcode{outFrame}
&
The \sphinxcode{frame}/\sphinxcode{frameName} when the button is in the Out state.
\\
\hline
\sphinxcode{downFrame}
&
The \sphinxcode{frame}/\sphinxcode{frameName} when the button is in the Down state.
\\
\hline
\sphinxcode{upFrame}
&
The \sphinxcode{frame}/\sphinxcode{frameName} when the button is in the Up state.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

When the user click to edit any of the \sphinxcode{(over/out/down/up)Frame} parameters it shows a dialog to select the new frame, from the list of frames of the same texture, atlas or sprite-sheet.


\subsection{TileSprite properties}
\label{\detokenize{canvas:tilesprite-properties}}
These are the tile properties supported by Canvas:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Property
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{tilePosition.x/y}
&
The offset position of the image that is being tiled.
\\
\hline
\sphinxcode{width}
&
The width of the tiling sprite.
\\
\hline
\sphinxcode{height}
&
The height of the tiling sprite.
\\
\hline
\sphinxcode{tileScale.x/y}
&
The scaling of the image that is being tiled.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

You can convert any sprite on a tile sprite by selecting it and press \sphinxcode{L}. This command also can be used to resize the tile. It is very helpful in games with a lot of tiles. In combination with tiles you can set the scene snapping, to create scenes based on fixed-size textures.

\noindent\sphinxincludegraphics{{ResizeTile}.png}


\subsection{Group properties}
\label{\detokenize{canvas:group-properties}}
Many time groups are used as proxy to apply properties or operations to all the children. Here we show the properties supported by the scene editor:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Property
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{physicsGroup}
&
Set to \sphinxcode{true} if you want to create this group as a Physics Group. A Physics Group is the same as an ordinary Group except that is has enableBody turned on by default, so any Sprites it creates are automatically given a physics body.
\\
\hline
\sphinxcode{physicsBodyType}
&
If \sphinxcode{physicsGroup} is \sphinxcode{true} this is the type of physics body that is created on new Sprites.
\\
\hline
\sphinxcode{physicsSortDirection}
&
If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.
\\
\hline
\sphinxcode{setAll}
&
A list of key/value pairs to generate a call to the \sphinxcode{setAll} method.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Physics groups}
\label{\detokenize{canvas:physics-groups}}
Physics groups are created with a different syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}ground} \PYG{o}{=} \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{physicsGroup}\PYG{p}{(}\PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Physics}\PYG{p}{.}\PYG{n+nx}{ARCADE}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{\PYGZus{}ground}\PYG{p}{.}\PYG{n+nx}{physicsSortDirection} \PYG{o}{=} \PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Physics}\PYG{p}{.}\PYG{n+nx}{Arcade}\PYG{p}{.}\PYG{n+nx}{LEFT\PYGZus{}RIGHT}\PYG{p}{;}
\end{sphinxVerbatim}

And as mentioned in the previous section, the goal of these kind of groups is to automatically enable physics bodies on the children.


\subsubsection{The \sphinxstyleliteralintitle{setAll} property}
\label{\detokenize{canvas:the-setall-property}}
The \sphinxcode{setAll} method is often used on the creation of scenes to initialize some values of the children objects. For example, if you are creating a platformer game you can group all the ground sprites on a group and set all the children to \sphinxcode{body.immovable = true} in this way:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{groundSprites}\PYG{p}{.}\PYG{n+nx}{setAll}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}body.immovable\PYGZdq{}}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now you don’t need to write it, you can click on the \sphinxcode{groundSprites} group and edit the \sphinxcode{setAll} property.

The \sphinxcode{setAll} property editor is very simple, it is a dialog with a key/value table. For each row of the table a new \sphinxcode{setAll} method call will be generated, the first column will be generated as the property name and the second column as the property value. Note that the name is generated inside a string expression \sphinxcode{"..."} but the value of the property is generated verbatim, so you can write any expression there, a string literal, a number, a boolean, a function call, the name of a variable, whatever you want.

\noindent\sphinxincludegraphics{{GroupSetAll}.png}


\subsection{Design-time object properties}
\label{\detokenize{canvas:design-time-object-properties}}
There are special properties that are not directly related to any Phaser API, else these are parameters provided to customize some editor’s behaviors like code generation of objects manipulation. These properties are under the “Editor” section of the Property Grid and we are explain them here:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Parameter
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{varName}
&
Used as var name in the generated code and label in the Outline window. Do not confuse it with the \sphinxstylestrong{name} parameter, which is part of the Phaser API.
\\
\hline
\sphinxcode{public}
&
To make public an object in the generated code. By default the objects variables are declared is local in the creation method, however public objects will be referenced by instance fields, so they are accesible from any other context.
\\
\hline
\sphinxcode{pick}
&
If set to \sphinxcode{false} then it cannot be selected in the scene.
\\
\hline
\sphinxcode{generate}
&
Set to \sphinxcode{false} if you need to keep the object in the scene but exclude it from the generated code.
\\
\hline
\sphinxcode{show}
&
Set to \sphinxcode{false} if you want to hide the object in the scene, but it will be included in the code generation. Useful when you want to temporarily hide distracting elements from the scene, like background objects.
\\
\hline
\sphinxcode{closed}
&
It only applies to groups. If set to \sphinxcode{true}, the group and the children are going to perform like a single object in operations like selection and dragging. It means, if you pick a child, the group is selected. Yet you can select the children in the Outline window.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Scene configuration}
\label{\detokenize{canvas:scene-configuration}}
As you can note the scene editor has two tabs: Design and Configuration. The Design tab contains everything about the objects and the Configuration tab contains other parameters not related with any object in particular else with the scene.

The Configuration tab is splitted in two panels, the left panel show a list of sections and the right panel a grid of properties of the selected section.

The configuration of sprites and group scenes are the same, it contains only an Editor section with design/code-generation specific parameters. The state scene contains the Editor section in addition to a State section with \sphinxcode{Phaser.State} related parameters.


\subsection{The Editor section}
\label{\detokenize{canvas:the-editor-section}}
This section contains a couple of parameters that are not related to any Phaser API else they are related to code generation or design functionalities:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Parameter
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxstylestrong{Scene}
&\\
\hline
\sphinxcode{width}
&
The width of the scene.
\\
\hline
\sphinxcode{height}
&
The height of the scene.
\\
\hline
\sphinxcode{backgroundColor}
&
The background color.
\\
\hline
\sphinxcode{gridColor}
&
The grid color
\\
\hline
\sphinxcode{showGrid}
&
Show the grid lines.
\\
\hline
\sphinxstylestrong{Snapping}
&\\
\hline
\sphinxcode{enable}
&
The snapping make it easy to place objects in a grid.
You can toggle this parameter with the \sphinxcode{E} key.
The \sphinxcode{W} key enable the snapping and set the
\sphinxcode{stepWidth} and \sphinxcode{stepHeight} with the size of
the selected object
\\
\hline
\sphinxcode{stepWidth}
&
The X step. Press \sphinxcode{W} to set this with the width
of the selected object.
\\
\hline
\sphinxcode{stepHeight}
&
The Y step. Press \sphinxcode{W} to set this with the height
of the selected object.
\\
\hline
\sphinxstylestrong{Source}
&\\
\hline
\sphinxcode{className}
&
The name of the generated class. It does not change
the name of the file.
\\
\hline
\sphinxcode{baseClass}
&
The name of the extended class, for example a custom \sphinxcode{MySprite} class that extends \sphinxcode{Phaser.Sprite}.
\\
\hline
\sphinxcode{userCode}
&
A series of chunk of codes that the user can insert into the generated code. In the {\hyperref[\detokenize{canvas:user-code}]{\sphinxcrossref{User code}}} section we explain this in details.
\\
\hline
\sphinxcode{lang}
&
The language or format of the code: JavaScript 5, JavaScript 6 or TypeScript.
\\
\hline
\sphinxcode{generateOnSave}
&
By setting it to \sphinxcode{false} it disable the automatic code generation.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{State scene configuration}
\label{\detokenize{canvas:state-scene-configuration}}
The configuration of sprite and group scenes are pretty the same, it only contains an Editor section. However the state scene has a State section with some paremeters related to the \sphinxcode{Phaser.State} API. At the moment this section only contains a few parameters but the ideal is to have a bigger set of parameters so it makes easy to the user to configure a state. Let’s see the list of parameters supported rigth now:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{Scale}
&
A section dedicated to the \sphinxcode{Phaser.ScaleManager} API (\sphinxcode{game.scale}).
\\
\hline
\sphinxcode{scaleMode}
&
The scaling method used by the ScaleManager when not in fullscreen.
\\
\hline
\sphinxcode{pageAlignHorizontally}
&
When enabled the Display canvas will be horizontally-aligned in the Parent container.
\\
\hline
\sphinxcode{pageAlignVertically}
&
When enabled the Display canvas will be vertically-aligned in the Parent container.
\\
\hline
\sphinxstylestrong{Physics}
&
A section dedicated to the \sphinxcode{Phaser.Physics} API (\sphinxcode{game.physics}).
\\
\hline
\sphinxcode{startSystem}
&
To start one of the selected physics engines (P2JS, NINJA, BOX2D, ARCADE).
\\
\hline
\sphinxstylestrong{Stage}
&
A section dedicated to the \sphinxcode{Phaser.Stage} API (\sphinxcode{game.stage})
\\
\hline
\sphinxcode{backgroundColor}
&
Gets and sets the background color of the stage. Note that it does not change the color of the scene in design-time.
\\
\hline
\sphinxstylestrong{Preload}
&
A section related to the Phaser loader API.
\\
\hline
\sphinxcode{pack}
&
Like in \sphinxcode{Phaser.Loader.pack()} this parameter accepts a list of sections of the pack files of the project. When you drop an asset to the scene it loads its pack section automatically, however it is possible that you create other sections with other kind of assets so in this parameter you can declare them to be loaded.
\\
\hline
\sphinxcode{isPreloader}
&
Set to \sphinxcode{true} if you like to use this state as a preloader state. More is explained in the {\hyperref[\detokenize{canvas:preloader-state-configuration}]{\sphinxcrossref{Preloader state configuration}}} section.
\\
\hline
\sphinxcode{preloadSprite}
&
This parameter is shown onny if the \sphinxcode{isPreloader} parameter is \sphinxcode{true}. When you edit this parameter it shows a dialog to select one of the scene sprites. This sprite will be used as the preload sprite as is explained in the \sphinxcode{Phaser.Loader.setPreloadSprite()} method: Set a Sprite to be a “preload” sprite by passing it to this method. A “preload” sprite will have its width or height crop adjusted based on the percentage of the loader in real-time. This allows you to easily make loading bars for games. The sprite will automatically be made visible when calling this.
\\
\hline
\sphinxcode{preloadSprite.direction}
&
The direction parameter of the \sphinxcode{Phaser.Loader.setPreloadSprite()} method. It should be \sphinxcode{HORIZONTAL} or \sphinxcode{VERTICAL}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Preloader state configuration}
\label{\detokenize{canvas:preloader-state-configuration}}
Often games load and process all the assets in a loading screen. In Phaser this loading screen is coded in a preloader state.
A preloader state is just like any other Phaser state, but the sprites are created in the \sphinxcode{preload} method (instead of the \sphinxcode{create} method) and the \sphinxcode{game.load.setPreloadSprite()} method is used to set the sprite to be used as progress bar.

The Phaser Project wizard of the editor provides a few project layout options, one of them is the \sphinxstylestrong{Multiple states with preloader (for larger games)}. We recommend to use that layout if you like to add a loading screen to your game. If you want to see a demo just select the \sphinxstylestrong{Include demo assets} parameter, it will create a project with a loading screen with a dino progress bar:

\noindent\sphinxincludegraphics{{CreatePreloaderDemoProject}.png}

The created project contains a \sphinxcode{Preloader.canvas} file with the preload sprite (the dino kid):

\noindent\sphinxincludegraphics{{PreloaderStateScene}.png}

In the Configuration tab, in the State section, you can see the \sphinxcode{isPreloader} is set to \sphinxcode{true} and the \sphinxcode{preloadSprite} is set to \sphinxcode{logo}:

\noindent\sphinxincludegraphics{{PreloaderStateConfig}.png}

When you run the project you will see how the dino is cropped from left to right as a progress of the loading. We recommend to test it on Chrome and enable the \sphinxcode{Network \textgreater{} Throttling} parameter, because serving from localhost is too fast to see the progress.

As we commented before, a key difference between a preloader state and a common state is that the sprites are created in the \sphinxcode{preload} method. Why? Because the \sphinxcode{create} is called only when all the assets are loaded, but what we need is to show the progress of the assets loading. Usually what is coded in the \sphinxcode{create} method is code to start the next state of the game. So the code of the \sphinxcode{Preloader.js} state of the previous project looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} start generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}

\PYG{c+c1}{// Generated by Phaser Editor v1.4.0 (Phaser v2.6.2)}


\PYG{c+cm}{/**}
\PYG{c+cm}{ * Preloader.}
\PYG{c+cm}{ */}
\PYG{k+kd}{function} \PYG{n+nx}{Preloader}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{State}\PYG{p}{.}\PYG{n+nx}{call}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/** @type Phaser.State */}
\PYG{k+kd}{var} \PYG{n+nx}{Preloader\PYGZus{}proto} \PYG{o}{=} \PYG{n+nb}{Object}\PYG{p}{.}\PYG{n+nx}{create}\PYG{p}{(}\PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{State}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{Preloader}\PYG{p}{.}\PYG{n+nx}{prototype} \PYG{o}{=} \PYG{n+nx}{Preloader\PYGZus{}proto}\PYG{p}{;}
\PYG{n+nx}{Preloader}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{constructor} \PYG{o}{=} \PYG{n+nx}{Preloader}\PYG{p}{;}

\PYG{n+nx}{Preloader}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{init} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{scale}\PYG{p}{.}\PYG{n+nx}{scaleMode} \PYG{o}{=} \PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{ScaleManager}\PYG{p}{.}\PYG{n+nx}{SHOW\PYGZus{}ALL}\PYG{p}{;}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{scale}\PYG{p}{.}\PYG{n+nx}{pageAlignHorizontally} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{scale}\PYG{p}{.}\PYG{n+nx}{pageAlignVertically} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n+nx}{Preloader}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{preload} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{pack}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}preloader\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}assets/pack.json\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}


        \PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}logo} \PYG{o}{=} \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{299}\PYG{p}{,} \PYG{l+m+mi}{231}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}logo\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{load}\PYG{p}{.}\PYG{n+nx}{setPreloadSprite}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}logo}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n+nx}{Preloader}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{create} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{nextState}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}


\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} end generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{} user code here \PYGZhy{}\PYGZhy{}}
\end{sphinxVerbatim}


\section{User code}
\label{\detokenize{canvas:user-code}}
Usually tools like Canvas provide a dedicated runtime to load the scenes in the Phaser games, however, that practice is not in the Phaser Editor’s philosophy of support plain Phaser, so we decided to use a compiler technique. This means that the scenes files are compiled into plain Phaser code, that can be integrated into the game as any other code written by the user.

The scenes are compiled into Sprite, Group and State classes, however there are many aspects of the game that are out of the scope of the tool, like for example the logic of the game is something that you have to write yourself. In this section we explain how you can insert your own code into the files generated by the editor.

There are two main ways to insert your code: (1) by writting it directly in certain parts of the file or (2) by writing it in the \sphinxcode{userCode} parameter of the scene configuration.


\subsection{Writting into the code file}
\label{\detokenize{canvas:writting-into-the-code-file}}
You are always allowed to write in any part of the generated file, but if you do not follow certain rules that code could be overwritten (lost) in the next compilation. There are very well defined sections of the file where you can write your code and it is preserved from compilation to compilation.
\begin{itemize}
\item {} 
As general rule just write your code in sections where it says \sphinxcode{// -{-} user code here -{-}}.

\item {} 
All the files have a \sphinxcode{/* -{-}- start generated code -{-}- */} line at the begining of the file, you can write your code before that.

\item {} 
All the files have a \sphinxcode{/* -{-}- end generated code -{-}- */} line at the end of the file, you can write your code after that.

\item {} 
In JavaScript 6 and TypeScript generated files you can write your code between the comments:
\begin{itemize}
\item {} 
\sphinxcode{/* sprite-methods-begin */} and \sphinxcode{/* sprite-methods-end */}

\item {} 
\sphinxcode{/* group-methods-begin */} and \sphinxcode{/* group-methods-end */}

\item {} 
\sphinxcode{/* state-methods-begin */} and \sphinxcode{/* state-methods-end */}

\end{itemize}

\end{itemize}

These sections are created in places that allow the user to add more elements to the classes, like methods or fields.


\subsection{Writting into the configuration}
\label{\detokenize{canvas:writting-into-the-configuration}}
The other way to insert user code into the generated file is to write it in the configuration of the scene (look at the Configuration tab the Editor section). The compiler reads the content of the \sphinxcode{userCode} parameter and write it into the file. In this case there is not risk to lost the code because it is saved in the Canvas file.

The \sphinxcode{userCode} parameter is divided by sections that refers to different points of the generated code. The idea is to insert code into the generated methods, \sphinxcode{before} and \sphinxcode{after} the method’s body. For example you can add code after the body of the method \sphinxcode{create} to perform other initialization routines, like create tween objects or audio objects or set other parameters to the current objects.

When you click to edit the \sphinxcode{userCode} parameter it opens a dialog with a tab for method, and each tab has two text boxes, one to write the \sphinxcode{before} code and other to write the \sphinxcode{after} code. For example a state scene \sphinxcode{userCode} has a tab for Constructor, Init, Preload and Create. All these tabs denote a method generated by the editor, so you can write your own code there.

For example let’s see a case of user code inserted in a state scene via configuration:

\noindent\sphinxincludegraphics{{UserCodeDialog}.png}

The code set there is inserted in the \sphinxcode{create} method of the compiled code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{Level}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{create} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{beforeCreate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{175}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}bg\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}tree\PYGZus{}} \PYG{o}{=} \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{127}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}environ\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}tree\PYGZhy{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}tree\PYGZus{}}\PYG{p}{.}\PYG{n+nx}{scale}\PYG{p}{.}\PYG{n+nx}{setTo}\PYG{p}{(}\PYG{l+m+mf}{2.0687500039674838}\PYG{p}{,} \PYG{l+m+mf}{2.072000037051153}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{453}\PYG{p}{,} \PYG{l+m+mi}{306}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}environ\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}bridge\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{addKeyboardShortcuts}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

We recommend to write just few lines of code via the \sphinxcode{userCode} configuration, specially because that dialog does not provide advanced features like code completion. In our demos and games what we do is to write a call to a method that was defined at the end of the file, in a protected zone, using the method explained in the {\hyperref[\detokenize{canvas:writting-into-the-code-file}]{\sphinxcrossref{Writting into the code file}}} section.

You can open the user code dialog directly from the scene, press \sphinxcode{Ctrl+Shift+U} or right click and select the \sphinxcode{Edit User Code} menu option.


\subsection{Public objects}
\label{\detokenize{canvas:public-objects}}
In the {\hyperref[\detokenize{canvas:object-properties}]{\sphinxcrossref{Object properties}}} section we mentioned the \sphinxcode{public} property of an object. It is a {\hyperref[\detokenize{canvas:design-time-object-properties}]{\emph{design time property}}} used to publish the objects beyond its context. To publish objects is needed to access a particular objects outside the \sphinxcode{create} method. The concept is simple, for each public object is created an instance fild that reference it. These public fields follow the format \sphinxcode{f\textless{}ObjectName\textgreater{}}, for example, if the object \sphinxcode{star} is marked as public a field \sphinxcode{fStar} is generated:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{Level}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{create} \PYG{o}{=} \PYG{k+kd}{function}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{\PYGZus{}star} \PYG{o}{=} \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{sprite}\PYG{p}{(}\PYG{l+m+mi}{67}\PYG{p}{,} \PYG{l+m+mi}{197}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}environ\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}star\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// public fields}

        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{fStar} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}star}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* \PYGZhy{}\PYGZhy{}\PYGZhy{} end generated code \PYGZhy{}\PYGZhy{}\PYGZhy{} */}

\PYG{n+nx}{Level}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{update} \PYG{o}{=} \PYG{k+kd}{function}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{this}\PYG{p}{.}\PYG{n+nx}{fStar}\PYG{p}{.}\PYG{n+nx}{angle} \PYG{o}{+=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Objects aligment and depth order}
\label{\detokenize{canvas:objects-aligment-and-depth-order}}
Position commands are always a powerful resource to build the layout of scenes. In Canvas we support some basic commands for alignment (left, right, top, bottom, center and middle) and for depth order (rise, rise to top, lower and lower to bottom).


\subsection{Aligment}
\label{\detokenize{canvas:aligment}}
The alignment commands are avilable in the conext menu and the Canvas toolbar:

\noindent\sphinxincludegraphics{{AlignObjects}.png}

The aligment commands are related to the parent group of the target object. If the sprite “head” belongs to the group “dino”, and we select the “left” aligment, then the local X position of “dino” will be set to \sphinxcode{0}, it means, that it will be at the left border of the group. Note that objects with no parent are set explicity belong to the global scene group.


\subsection{Depth order}
\label{\detokenize{canvas:depth-order}}
Pretty similar to aligment commands there are the order commands. To apply them first you select the target objects and click on the corresponfing toolbar button or context menu option.

The “order” commands send an object back and forward, in the display list of its group.

\sphinxstyleemphasis{NOTE: In Phaser there are some aligment constants and methods, but they are more (we think) about to align an object in runtime. It is a great resource for those who set the game layout “by hand”. We are exploring this new features and in future versions of Canvas we can take advantage of it or reuse some concepts, like align in a grid.}


\section{Common editing operations}
\label{\detokenize{canvas:common-editing-operations}}
Canvas support common editing operations like:
\begin{itemize}
\item {} 
Cut, Copy and Paste of the objects.

\item {} 
Undo, Redo of all major operations on nodes.

\item {} 
Zoom in/out/restore. Scroll the wheel of the mouse to zoom in/out, and the Zoom 1:1 button in the toolbar.

\item {} 
Pan the scene, by hodling the middle mouse button and dragging in any direction.

\item {} 
Object selection, by clicking it or dragging the mouse and create a selection box.

\item {} 
Object moving, first you select the objects and then you drag them.

\end{itemize}


\section{Removing distractions}
\label{\detokenize{canvas:removing-distractions}}
The default layout in Phaser Editor is a bit charged, it opens the Project Explorer, Chains view, Problems view, Preview view and Assets view, in addition to the editor area. However, Eclipse (the platform behind Phaser Editor) has a very customizable and flexible layout. You can minimize windows and open them with a quick look, or dock the windows (the right term for them is “views”) in the screen corners or stack them. We encourage you to read the Workbench User Guide bundled in Phaser Editor.

Drag the windows to a corner or fold it with other windows:

\noindent\sphinxincludegraphics{{DockedWindows}.png}

A window (like the scene editor) can be detached from the main application by dragging it away from the main window:

\noindent\sphinxincludegraphics{{DetachedWindow}.png}

Double click in the scene editor tab (or press \sphinxcode{Ctrl+M}), it maximizes the editor window and minimizes all the other windows around. You will get all the space for the scene editor but at the same time you can do a quick look (by clicking on its icon) to the minimized windows (like the Assets or Preview windows):

\noindent\sphinxincludegraphics{{QuickLookMinWindow}.png}

Other elements you can remove are the property grid and the outline windows that are inside the scene editor. To do this just click on the “side panel” icon of the toolbar:

\noindent\sphinxincludegraphics{{ToolbarIconsSidePanel}.png}

Really you don’t need these panels all the time open, you always can edit the properties of an object by pressing \sphinxcode{Q}, it opens a quick edit dialog with the the property grid inside:

\noindent\sphinxincludegraphics{{QuickEditDialog}.png}

To navigate the scene you can open the Quick Outline window by pressing \sphinxcode{Ctrl+O}:

\noindent\sphinxincludegraphics{{QuickOutlineWindow}.png}

To quicly add objects to the scene you can use the fast view to the minimized windows but also you can use the Palette, that is a small panel where you can collect the assets to be used in the scene. In the section {\hyperref[\detokenize{canvas:from-the-palette}]{\sphinxcrossref{from the palette}}} it is explained in details.


\chapter{Coding The Game: The JavaScript Editor}
\label{\detokenize{jseditor:coding-the-game-the-javascript-editor}}\label{\detokenize{jseditor::doc}}
With Phaser you write the game with JavaScript as main language (there is also support for TypeScript). In Phaser Editor the JavaScript programming is a first citizen, the JavaScript editor is the more important component for us, and we do an extra effort to build the best experience for the Phaser developer.

The JavaScript editor is part of the JSDT (Eclipse Web Tools) and we extended and modified it to adjust it to the Phaser API and style.

When you create a Phaser Project the main JS file is opened in the editor. To open the JS editor manually you can navigate to the JS file in the Project Explorer and double click on it.


\section{Phaser API smart code completion}
\label{\detokenize{jseditor:phaser-api-smart-code-completion}}
The JS editor has a \sphinxstyleemphasis{“a complex inference engine”} to bind JS elements with static type information. We think it works very well with the Phaser API. We made a Phaser API library to make it easier for the inference engine to compute the static type of the JS expressions.

If you follow certain coding structure you will enjoy a smart completion of the Phaser methods, properties and classes. JavaScript is a dynamic language and there are cases where compute the type of an expression is hard or impossible. However, in Phaser Editor you can annotate with static type information different statements like var declarations, method returns, method parameters and prototypes. See the next section.

Member proposals:

\noindent\sphinxincludegraphics{{ApiSmartCompletion}.png}

Arguments proposals:

\noindent\sphinxincludegraphics{{APISmartCompletionsParams}.png}

Drawbacks:

Note in the proposals you see types like \sphinxcode{Phaser\_Game} or \sphinxcode{Phaser\_Sprite}, etc.. It happens because JSDT does not understand the concept of namespaces, so we had to tweak the editor to simulate namespaces. This means that you can autocomplete \sphinxcode{Phaser.Sprite} but also \sphinxcode{Phaser\_Sprite}, however the last one is not valid in Phaser. We are working on replace the JSDT inference engine for a more accurate tool based on the Language Server Protocol of Microsoft.


\section{Type annotation on a var declaration}
\label{\detokenize{jseditor:type-annotation-on-a-var-declaration}}
Annotate var declarations is the general way to set the static type of a variable:

\noindent\sphinxincludegraphics{{TypeDecl_Var}.png}

This is something that you would like to use in a callback function:

\noindent\sphinxincludegraphics{{TypeDecl_Context}.png}


\section{Type annotation on a method declaration}
\label{\detokenize{jseditor:type-annotation-on-a-method-declaration}}
In a method you can declare the type of the return and the parameters:

\noindent\sphinxincludegraphics{{TypeDecl_Method}.png}

\noindent\sphinxincludegraphics{{VarTypeFromMethodReturn}.png}

Unfortunately, for now, the type annotations are not supported in anonymous functions.


\section{Type annotation on prototype declaration}
\label{\detokenize{jseditor:type-annotation-on-prototype-declaration}}
In Phaser you are not forced to use type inheritance, however, a recommended practice is to split your game in functional components like game states, custom sprites and groups. In Phaser Editor we encourage to use prototype inheritance between other reasons because it helps with auto completion.

In JavaScript you can define a prototype like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{NewClass}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{BaseClass}\PYG{p}{.}\PYG{n+nx}{call}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n+nx}{NewClass}\PYG{p}{.}\PYG{n+nx}{prototype} \PYG{o}{=} \PYG{n+nb}{Object}\PYG{p}{.}\PYG{n+nx}{create}\PYG{p}{(}\PYG{n+nx}{BaseClass}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{NewClass}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{constructor} \PYG{o}{=} \PYG{n+nx}{NewClass}\PYG{p}{;}

\PYG{n+nx}{NewClass}\PYG{p}{.}\PYG{n+nx}{myNewMethod} \PYG{o}{=} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// ...}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

In Phaser Editor if you annotate the prototype with the \sphinxcode{BaseClass} then in the context of the prototype functions you will get the smart completions of the \sphinxcode{BaseClass} too. Just take a look to the files generated by the \sphinxcode{New \textgreater{} Group Prefab File}, that creates a custom group:

\noindent\sphinxincludegraphics{{TypeDecl_Prototype}.png}

Note that we annotate an intermediate \sphinxcode{MyGroup\_proto} var with the \sphinxcode{Phaser.Group} type, then we assign this var to the new prototype declaration.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** @type Phaser.Group */}
\PYG{k+kd}{var} \PYG{n+nx}{MyGroup\PYGZus{}proto} \PYG{o}{=} \PYG{n+nb}{Object}\PYG{p}{.}\PYG{n+nx}{create}\PYG{p}{(}\PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Group}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{MyGroup}\PYG{p}{.}\PYG{n+nx}{prototype} \PYG{o}{=} \PYG{n+nx}{proto}\PYG{p}{;}
\PYG{n+nx}{MyGroup}\PYG{p}{.}\PYG{n+nx}{prototype}\PYG{p}{.}\PYG{n+nx}{constructor} \PYG{o}{=} \PYG{n+nx}{MyGroup}\PYG{p}{;}
\end{sphinxVerbatim}

This is not the more beautiful thing of the world, we prefer to use something like a \sphinxcode{@extends} JSDoc tag, but for now it is not possible. We recommend to use the new file wizards, they generated a code that can be “understood” by the JavaScript editor.


\section{Phaser API hover help}
\label{\detokenize{jseditor:phaser-api-hover-help}}
The hover help is about to get the documentation of a Phaser API element just with a mouse hover. It works pretty similar to the smart completions, the type inference engine should be able to compute the static type of the hover element, so you have to follow the same coding style (annotating the declarations with JSDoc tags) explained in the previous section.

\noindent\sphinxincludegraphics{{HoverAPI}.png}


\section{Code templates}
\label{\detokenize{jseditor:code-templates}}
With the code templates you can get snippets of code to cover specific Phaser tasks. These templates are the same are used in the official Phaser {[}online editor{]}{[}10{]}.

\noindent\sphinxincludegraphics{{CodeTemplates}.png}


\section{Asset keys proposals}
\label{\detokenize{jseditor:asset-keys-proposals}}
When you define your assets in an asset pack file then the JS editor read the asset keys and show them in the proposals popup. These proposals are listed when the content assist popup is invoked in a string context:

\noindent\sphinxincludegraphics{{AssetKeysCompletion}.png}

As you can see in the above screenshot, the asset keys are shown in the information control of the content assist popup. In the case of audio files it plays the sound.


\section{File names proposals}
\label{\detokenize{jseditor:file-names-proposals}}
Also file names are shown in the content assist popup and they are visualized in the information control. In the next image are listed all the file names that match the \sphinxcode{png} string:

\noindent\sphinxincludegraphics{{FilesCompletion}.png}


\section{Easing names proposals}
\label{\detokenize{jseditor:easing-names-proposals}}
Tweens are part of any Phaser game. When you create a tween you should provide the easing to be used in the animation. A common way to identify the easing is giving the easing function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{tween}\PYG{p}{(}\PYG{n+nx}{item}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{to}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{y}\PYG{o}{:} \PYG{l+m+mi}{240}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{2400}\PYG{p}{,} \PYG{n+nx}{Phaser}\PYG{p}{.}\PYG{n+nx}{Easing}\PYG{p}{.}\PYG{n+nx}{Bounce}\PYG{p}{.}\PYG{n+nx}{Out}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

But also you can write the easing name:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nx}{game}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{.}\PYG{n+nx}{tween}\PYG{p}{(}\PYG{n+nx}{item}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{to}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{y}\PYG{o}{:} \PYG{l+m+mi}{240}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{2400}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}Bounce.easeOut\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In Phaser Editor you get easing names completions:

\noindent\sphinxincludegraphics{{EasingLiteralAssist}.png}

Look the ball is animated with the selected easing.


\section{Errors, warnings and quick fix}
\label{\detokenize{jseditor:errors-warnings-and-quick-fix}}
By default Phaser Editor checks for syntax and semantic problems (errors and warnings). These problems are shown in the Problems view. In the JS editor the expression with problems is underlined with a yellow or red color in dependence of if it is a warning or an error.

Many of these problems can be fixed automatically with the Quick Fix command. When you get a problem, put the cursor on the error and press \sphinxcode{CTRL+1}, the Quick Fix dialog is shown with different options.

Hover the mouse on the error marker:

\noindent\sphinxincludegraphics{{QuickFix_1}.png}

Then press \sphinxcode{Ctrl+1} to fix it:

\noindent\sphinxincludegraphics{{QuickFix_2}.png}

You can change the validator settings to ignore a kind of problem or treat it as a warning or error. These settings can be changed in a specific project (right click on the project and select Properties) or for the whole workspace (in the main menu \sphinxcode{Windows \textgreater{} Preferences}).

\noindent\sphinxincludegraphics{{JSValidationSettings}.png}


\section{Preview}
\label{\detokenize{jseditor:preview}}
The JavaScript editor supports some preview features. When you hover a file name string, then it shows a popup with a preview of that file. In a similar way, if you hover the name of an \sphinxhref{assets\_manager.html}{asset entry in the asset pack} , then it shows a popup with a preview of the identified asset.

To quick preview an object you can hover its name but also you can put the cursor in the middle of the name and type \sphinxcode{Ctrl+Alt+V} that command opens the identified object in the \sphinxhref{preview\_window.html}{Preview window}.

\noindent\sphinxincludegraphics{{JSEditorAssetPreview}.png}


\chapter{Chains: Search on the Phaser Docs}
\label{\detokenize{chains:chains-search-on-the-phaser-docs}}\label{\detokenize{chains::doc}}
Phaser Chains is a tool we did to search the Phaser docs. It has an {[}original online version{]}{[}1{]} and was integrated in some editors like Brackets, IntelliJ, Eclipse and the \sphinxhref{http://phaser.io/learn/chains}{Phaser website}.

In Phaser Editor we support a native and well integrated version of Chains. When you open Phaser Editor, by default it shows the Chains view in the bottom panel. It is the main source you have to access the Phaser documentation.

However Chains is used by hundred of developers is possible some methods or properties are not listed there, it happens because to build the chains we parse the Phaser jsdocs and this is not always 100\% accurate, so if you see there is a method or property is missing in Chains we recommend to checkout the official Phaser Documentation.


\section{Search for chains}
\label{\detokenize{chains:search-for-chains}}
The main difference of this tool with a common documentation view is that you search for a method chain like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
game.add.
\end{sphinxVerbatim}

As you can see the Phaser API makes an extensive use of method/properties chains like \sphinxcode{game.load.image()} or \sphinxcode{sprite.animations.add}. So the Chains idea is that you type the chain you are interested to investigate and then it shows all the matching chains of the Phaser API.

\noindent\sphinxincludegraphics{{ChainsSearchAPI}.png}

In the screenshot you can see in the left panel it shows the matching chains. If you click it then it opens the documentation of the last element of the chain. This documentation is shown in the JSDoc tab that is next to the Search tab:

\noindent\sphinxincludegraphics{{ChainsJSDocTab}.png}

In addition to the JSDoc you can see the source code of a chain. Just right click on a chain and select \sphinxcode{Show Source Code}. It opens an editor with the source code of the chain.


\section{Search examples}
\label{\detokenize{chains:search-examples}}
An important source to learn the Phaser stuff is browsing the examples are published in the Phaser website and included in the Phaser download. These examples are small but complete snippets of code that demonstrate and explain a particular question of Phaser.

In Phaser Editor we provide these examples as project templates so you can study Phaser creating an example project. However, it is very useful to have the examples also available in Chains, they are a perfect complement for the  documentation. So when you search for a chain, in the right panel of Chains it shows the matching lines in the different examples. In this way you can discover how that API is used in Phaser.

To see the complete example, as we said, you can create a project based in a particular example, but also in Chains you can click the row of the example and it opens the complete example’s file.

The drawback of an example opened from the Chains is that you cannot run it, but the advantage is that you get a quick view of it.


\section{Using wildcards}
\label{\detokenize{chains:using-wildcards}}
A powerful feature of Chains is that you can search using wildcards \sphinxcode{*}. This allow to you to find chains that you are not sure how they are writing but you remember some parts of it. For example, if in your game you need to listen for an input down event you can write a search pattern like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
game*down*add
\end{sphinxVerbatim}

It matches with:

\noindent\sphinxincludegraphics{{ChainsWildcard}.png}

If you want to know what classes are extending the \sphinxcode{Phaser.Sprite} class then you can search for:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
extends*Sprite
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{ChainsExtends}.png}


\chapter{The Preview Window}
\label{\detokenize{preview_window:the-preview-window}}\label{\detokenize{preview_window::doc}}
As the name suggest, in this window you can visualize different objects, specially the asset declarations of the \sphinxhref{assets\_manager.html}{asset pack} and media files (images, sounds, videos).

This Preview window usually show details of the previewed object like dimension, name, etc… In addition in the case of textures you can \sphinxhref{canvas.html\#from-the-preview-window}{drag the frames drop them into a scene}, to create new obejcts.

To preview an asset you can drag it from the Assets explorer or Project Explorer and drop it into the Preview window, or select an asset and press \sphinxcode{CTRL+ALT+V}.

In the JavaScript editor, if you put the cursor on a string literal and press \sphinxcode{CTRL+ALT+V}, the asset of the same name will be opened in the Preview.

\noindent\sphinxincludegraphics{{DropAssetPreview}.png}

Note in the menu of the Preview there are the following options:

\noindent\sphinxincludegraphics{{PreviewMenu}.png}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Open New Window
&
Opens a new Preview, so you can visualize many objects at the same time.
\\
\hline
Refresh (\sphinxcode{F5})
&
To update the content. This is useful when the object was changed by an external tool.
\\
\hline
Clear
&
Empty the window.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{The sprite-sheet preview}
\label{\detokenize{preview_window:the-sprite-sheet-preview}}
When you open a sprite-sheet asset in the Preview window it shows a special control where you can play the whole sprite-sheet as a single animation. It is useful for quick animations preview and can ve used when the game is not based on visual scenes, that have their own animations editor.

\noindent\sphinxincludegraphics{{SpritesheetPreview}.png}


\section{The textures atlas preview}
\label{\detokenize{preview_window:the-textures-atlas-preview}}
The preview of a textures atlas asset shows the image of the complete texture and drop-down with a list of the sprite (frame) names. To focus on a particular sprite of the map you can click it or select it in the drop-down. In addition you can drag a frame and drop it in the same (or other) Preview window to preview only that frame.

\noindent\sphinxincludegraphics{{AtlasPreview}.png}


\chapter{Texture Packing Editor}
\label{\detokenize{texture_packer::doc}}\label{\detokenize{texture_packer:texture-packing-editor}}
Texture maps (or atlases) is an important resource that developers have to improve the performance of their games.

In Phaser Editor we give full support to texture atlases, we provide the Texture Atlas Editor to do the job. There are other external tools that you can use but we think that integrating a texture packer in Phaser Editor is part of our philosophy of deliver a complete and integrated development environment.

Our Atlas Editor uses the \sphinxhref{https://github.com/libgdx/libgdx/tree/master/extensions/gdx-tools}{LibGDX Texture Packer}, it features the MaxRect algorithm and can be tuned to satisfy the requirements of the majority of the games.


\section{Create the atlas}
\label{\detokenize{texture_packer:create-the-atlas}}
To create an atlas click on \sphinxcode{File \textgreater{} New \textgreater{} Atlas Generator File}, it opens a dialog to set the name of the atlas and the container folder. This container folder should be a sub-folder of the \sphinxcode{WebContent} folder.

\noindent\sphinxincludegraphics{{NewAtlasWizard}.png}

When you press \sphinxstylestrong{Finish}, a file \sphinxcode{myatlas.atlas} is created and opened in the Atlas Editor. This file does not contains any relation with Phaser, else it contains Phaser Editor related stuff, like the atlas settings and the path of the source images. So you should exclude it from a game build,  but keep it on your game development source.

One time the atlas file is created and the Atlas Editor is open to edit it then you can start adding images to the atlas.

To add the image files to the atlas follow these steps:
\begin{itemize}
\item {} 
Select the image files in the Project Explorer.

\item {} 
Drag the files and drop them into the atlas editor. You can also drop complete folders.

\item {} 
Save the atlas file (\sphinxcode{Ctrl+S} or \sphinxcode{File \textgreater{} Save}). It generates the Phaser atlas JSON file (with the JSON Hash format) and the texture image (PNG) file.

\end{itemize}

\noindent\sphinxincludegraphics{{AtlasImportImages}.png}

The last step, to save, is very important, remember \sphinxcode{myatlas.atlas} file is an internal Phaser Editor file, it is a configuration file used to generate the final JSON atlas and PNG texture file to be used in the game. So when you save the editor a \sphinxcode{myatlas.json} and \sphinxcode{myatlas.png} files are generated. These are the files you should load in your game. Also note the source images are not placed under the \sphinxcode{WebContent} folder else under the \sphinxcode{Design} folder. Phaser Editor creates the \sphinxcode{Design} folder and encourages the developers to put there the files are not included in the game but are used to generate the game assets, like is the case of the atlas source images.

To load the atlas in your game you can use the \sphinxcode{Phaser.Loader.atlasJSONHash()} method or load the \sphinxhref{assets\_manager.html}{Asset Pack} file.

\noindent\sphinxincludegraphics{{AtlasSaveGenerateFiles}.png}


\section{Tuning the atlas parameters}
\label{\detokenize{texture_packer:tuning-the-atlas-parameters}}
Texture MAPS can be used in different objects of your game like sprites, tile sprites, sprite-sheets, etc.. Often you should adjust the parameters of the packer to get a texture applicable to the different functions.

To change these parameterS click the “settings icon” in the editor toolbar. It opens the Settings dialog:

\noindent\sphinxincludegraphics{{AtlasEditorSettings}.png}

The settings are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Parameter
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Documentation
\unskip}\relax \\
\hline
\sphinxcode{Min/Max Size}
&
To change the size of the texture image. There are cases where the editor generates more than one Phaser (JSON) atlas files. It is because the texture has no space for all images so it creates another atlas to put there the remaining images. However you can change the max size of the texture to make space for all the sprites.
\\
\hline
\sphinxcode{Size constraints}
&
You can select \sphinxcode{Any Size} (default) or \sphinxcode{POT (Power of 2)}. In the second case the editor generates a texture with a size power of 2. In some platforms this kind of textures performs better.
\\
\hline
\sphinxcode{Padding}
&
It controls the spacing between the sprites. It is useful to remove artifacts from sprites animations, tile sprites, in general when the source images has color pixels in the borders. By default it puts 2.
\\
\hline
\sphinxcode{Strip white spaces}
&
To remove the extra space of sprites. If your source images have extra space (transparent areas) around the picture, then activating these parameters the editor generates a texture that removes that spaces and a JSON file that specify to Phaser to render the sprites with the right spacing. By default these parameters are on.
\\
\hline
\sphinxcode{Use indexes}
&
To sort the sprites by using a \sphinxcode{\_01.png} sufix in the source files.
\\
\hline
\sphinxcode{Alias}
&
Equal images are packed once.
\\
\hline
\sphinxcode{Grid}
&
To pack the images in a uniform grid. You can use this together with the Indexes option to create spritesheets.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Multiple pages}
\label{\detokenize{texture_packer:multiple-pages}}
As we mentioned before, it is possible that one texture has no enough space for all the sprites, then many “pages” or textures are generated to place the remaining sprites.

When this happens the editor creates multiple tabs to show all the textures and generates the Phaser atlas files with a number suffix. For example, if the packer generates two textures we get the files \sphinxtitleref{myatlas1.json}, \sphinxtitleref{myatlas1.png}, \sphinxtitleref{myatlas2.json} and \sphinxtitleref{myatlas2.png}:

\noindent\sphinxincludegraphics{{AtlasMultiPage}.png}


\section{The side panel}
\label{\detokenize{texture_packer:the-side-panel}}
Close to the settings icon there is the “side panel” icon. By default the side panel is hidden but you can show it selecting that icon.

This panel shows the name of the sprites and a small window with the sprites and pages information.

When you click on a sprite in the right panel (canvas), that sprite is selected in the side panel, and when you select a sprite in the side panel, it is highlighted in the texture canvas.

You can delete some sprites by selecting it and pressing the \sphinxtitleref{DEL} key or clicking on the delete icon that is placed in the editor’s toolbar. Remember each time you change the atlas you should save it to generate the Phaser files.

\noindent\sphinxincludegraphics{{AtlasSidePanel}.png}


\section{Update the atlas with external changes}
\label{\detokenize{texture_packer:update-the-atlas-with-external-changes}}
In the editor’s toolbar you can see a “gear” icon, click it to re-build the atlas. When you change the source image files then you should rebuild the atlas to regenerate the texture, do this by pressing that “gear” icon.

When you rebuild the atlas the editor shows a dialog to confirm that you want to save the atlas, if you accept, then the atlas  is saved and the Phaser atlas files are generated.


\chapter{Optimize The PNG Image Files}
\label{\detokenize{optipng:optimize-the-png-image-files}}\label{\detokenize{optipng::doc}}
Phaser Editor provides a simple utility based on the well known \sphinxhref{http://optipng.sourceforge.net/}{OptiPNG} tool to reduce the file size of the PNG images. It is very important that you keep the file size of your game as small as possible, it improves the game loading speed.

To optimize the PNG files you should first select the files or the folder of the files in the Project Explorer, then click the Optiomize PNG button in the main toolbar or open the context menu and select the \sphinxcode{Optimize selected PNG files} option.

It opens a dialog with the progress of the optimization process.

\noindent\sphinxincludegraphics{{OptiPNGIcon}.png}

\noindent\sphinxincludegraphics{{OptiPNGDialog}.png}


\section{Settings}
\label{\detokenize{optipng:settings}}
You can change the level of compression in the preference page of the optimizer: \sphinxcode{Preferences \textgreater{} Phaser Editor \textgreater{} Optimize PNG}.

\noindent\sphinxincludegraphics{{OptiPNGSettings}.png}


\chapter{Audio Sprites Editor}
\label{\detokenize{audio_sprites:audio-sprites-editor}}\label{\detokenize{audio_sprites::doc}}\begin{quote}

Audio Sprites are generally a ‘hang over’ from pre-Web Audio days, where they were literally the only way to have multiple sound effects / music in a game. However they’re still pretty useful even for web audio playback, as it means less http requests and mostly retains compatibility with older devices that still don’t support Web Audio, or browsers like IE that don’t at all either. \textendash{} \sphinxhref{http://www.html5gamedevs.com/topic/6582-advantages-audio-sprites/\#entry39190}{Richard Davey} .
\end{quote}

Audio Sprites are a combination of audio files and a JSON configuration. The JSON follows the format of that created by \sphinxhref{https://github.com/tonistiigi/audiosprite}{tonistiigi}. In Phaser Editor we provide an editor to easy create and edit audio sprites.

To create an audio sprites go to the File menu and select \sphinxcode{New \textgreater{} Audio Sprites File} and it opens a dialog to select the container folder and set the file name.

\noindent\sphinxincludegraphics{{AudioSpriteWizard}.png}

When you press finish it creates a JSON file with the sprites definitions. This file is opened in the Audio Sprite Editor, then you can drag some audio files from the Project Explorer and drop them into the editor. When you drop the audio files into the editor they are appended to a single audio file. Remember that audio sprites contains a “big” audio file formed by the concatenation of the different sounds spaced by a little time of silence.

For example, if your audio sprites JSON is \sphinxcode{sounds.json}, then when you add audio files to the editor, these audio files are appended to a \sphinxcode{sounds.wav} file new sprites entries are created with default values.

This resultant \sphinxcode{sounds.wav} file is transcoded to MP3 and OGG formats, so at the end you get two other \sphinxcode{sounds.mp3} and \sphinxcode{sounds.ogg} files.

All the audio manipulation is done using the \sphinxhref{https://www.ffmpeg.org/}{FFMpeg} tool.

\noindent\sphinxincludegraphics{{AudioSpritesEditor}.png}

As you can see in the above image, the editor has two panels, the top panel show the audio waves and the range of the sprites. When you move the mouse over this panel a vertical line indicates the time at the cursor’s position.

In the bottom panel are listed the sprites. You can edit, add or remove the sprites. To edit it select the row of the sprite and click cell with the value you want to change.

If you drag new audio files, new sprites are created and get the name and range from the audio files.

It is possible that some audio files cannot be concatenated with a good result, audio files have a diversity of sources but we process them with the same ffmpeg configuration. In any case, if you have troubles concatenating the files, you can do it with a tool like Audacity and then edit the sprites info with Phaser Editor.


\chapter{Update and Upgrade}
\label{\detokenize{update::doc}}\label{\detokenize{update:update-and-upgrade}}
In Phaser Editor we do a distinction between update and upgrade.

In theory, update and upgrade is the same, the difference is that by default the editor is going to be updated only with the changes made for the current version.

For example, if you download version \sphinxcode{1.4.0} the editor will receive automatic updates for version \sphinxcode{1.4.1}, \sphinxcode{1.4.2} and so on.

If you want to upgrade the editor to version \sphinxcode{1.5.0} then you have to do it manually.


\section{Update}
\label{\detokenize{update:update}}
As we said, the update is done automatically. Each time the editor starts it looks for updates, if there are updates available then it will ask confirmation to install them.

However you can check for updates at any time manually, just click on \sphinxcode{Help \textgreater{} Check for Updates}.

The installing of the updates is straightforward, it will show the new plugins to be installed/updates and the license of them. Just press OK to everything.

If you find any issue please \sphinxhref{https://github.com/boniatillo-com/PhaserEditor/issues}{contact with us} .


\section{Upgrade}
\label{\detokenize{update:upgrade}}
To upgrade from one version to other these are the steps:
\begin{itemize}
\item {} 
Open the Available Software Sites \sphinxcode{Windows \textgreater{} Preferences \textgreater{} Install/Update \textgreater{} Available Software Sites}.

\item {} 
Press the Add button to add a new update site, the one with the version you are intersted in:

\end{itemize}

\noindent\sphinxincludegraphics{{AddUpdateSite1}.png}
\begin{itemize}
\item {} 
Press ok, ensure the new site is checked and press OK to close the preferences dialog.

\end{itemize}

\noindent\sphinxincludegraphics{{AddUpdateSite2}.png}
\begin{itemize}
\item {} 
Manually check for updates (\sphinxcode{Help \textgreater{} Check for Updates}), it should prompt the new updates, install them as usually.

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}